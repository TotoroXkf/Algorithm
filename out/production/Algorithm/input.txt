### 寻找二叉搜索树的公共祖先节点
> 二叉搜索树给定两个节点，找到公共的祖先

**思路**

如果当前节点处于两个节点之间，那就说明它就是公共祖先节点。

如果在区间的右半部分，说明公共祖先在左子树部分。就把左节点传下去递归

反之就是传递右节点传下去递归

**代码**

```python
def lowest_common_ancestor(root, p, q):
    """
    :type root: TreeNode
    :type p: TreeNode
    :type q: TreeNode
    :rtype: TreeNode
    """
    if (p.val <= root.val <= q.val) or (p.val >= root.val >= q.val):
        return root

    elif p.val < root.val and q.val < root.val:
        return lowest_common_ancestor(root.left, p, q)

    else:
        return lowest_common_ancestor(root.right, p, q)
```

###  找出二叉树每层的最大值
> 如题

**思路**

层序遍历，用None来隔断每层，记录每层最大值即可

**代码**

```python
def largest_values(root):
    """
    :type root: TreeNode
    :rtype: List[int]
    """
    if root is None:
        return []
    queue = [root, None]
    res = []
    max_value = -2147483648
    while queue:
        element = queue.pop(0)
        if element is not None:
            max_value = max(max_value, element.val)
            if element.left is not None:
                queue.append(element.left)
            if element.right is not None:
                queue.append(element.right)
        else:
            res.append(max_value)
            max_value = -2147483648
            if len(queue) > 0:
                queue.append(None)
    return res
```

### 二叉树中所有距离为 K 的结点
> 给出二叉树和一个特定节点，在给出k表示距离，返回所有和这个节点相距为k的节点的值

**思路**

照着题目的意思写即可。先找到指定节点，然后从指定节点向下遍历k层。再然后向前返回的时候返回一个距离表示指定节点和当前节点的距离，再从当前节点向下遍历k-distance层即可
递归结束也就都找完了


**代码**

```python
def distance_k(root, target, k):
    """
    :type root: TreeNode
    :type target: TreeNode
    :type K: int
    :rtype: List[int]
    """
    res = []
    find_node(root, target, k, res)
    return res


def find_node(node, target, k, res):
    """
    :type target:TreeNode
    :type node:TreeNode
    :type k:int
    :rtype :int
    :type res:list[int]
    """
    if node is None:
        return -1
    if node is target:
        search_node(node, None, 0, k, res)
        return 0
    else:
        distance = find_node(node.left, target, k, res)
        if distance != -1:
            search_node(node, node.left, distance + 1, k, res)
            return distance + 1
        distance = find_node(node.right, target, k, res)
        if distance != -1:
            search_node(node, node.right, distance + 1, k, res)
            return distance + 1
        return -1


def search_node(node, avoid, current, k, res):
    """
    :type current :int
    :type node: TreeNode
    :type avoid:TreeNode
    :type k: int
    :type res:list
    """
    if node is avoid or node is None:
        return
    if current == k:
        res.append(node.val)
    else:
        search_node(node.left, avoid, current + 1, k, res)
        search_node(node.right, avoid, current + 1, k, res)
```