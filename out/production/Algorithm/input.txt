### 判断矩阵是否相交

>给出两个矩阵的左下角坐标和右上角坐标，判断是否相交

**思路**

两个矩形想要相交，一定存在以下情况（以第一个矩形作为参考系）
- 第二个矩形的右上角一定在第一个矩形的左下角的右边
- 第二个矩形的左下角一定在第一个矩形的右上角的左边

写成代码判断即可

**代码**

```python
def is_rectangle_overlap(self, rec1, rec2):
    """
    :type rec1: List[int]
    :type rec2: List[int]
    :rtype: bool
    """
    bl_x1, bl_y1, tr_x1, tr_y1 = rec1
    bl_x2, bl_y2, tr_x2, tr_y2 = rec2

    return ((bl_x1 < tr_x2) and (bl_x2 < tr_x1)) and ((bl_y1 < tr_y2) and (bl_y2 < tr_y1))
```

### 给出图的每条边，找出最矮树的根节点
> 给出一个二维数组，每一个一维数组含有两个元素，表示从[0]到[1]，然后这个一维数组就表示了无向图中的边，将任意一个节点看作root，都可以得到一颗n叉树。求生成最矮树的root节点

**思路**

如果要树最矮，表示从根节点到叶子节点的路径比较短，那么，放到无向图中来看的话，就意味着越在图的中心部分越有利。所以做法就是不断删除外圈元素，剩下的就是中心。

利用字典保存点和联通的点。这个是双向的，保存（1，0），也要保存（0，1）
然后循环双向删除只有一个连通的节点。只有一个连通说明它们是图的最外圈。然后记录新的只有一个连通节点的节点。继续循环

一直删到只剩下一个或者两个节点（图的中心一定是1个或者两个节点，不可能再多），剩下的就是答案。

**代码**

```python
def find_min_height_trees(n, edges):
    """
    :type n: int
    :type edges: List[List[int]]
    :rtype: List[int]
    """
    if edges:
        graph = {}
        for i in range(0, n):
            graph[i] = []
        for value in edges:
            graph[value[0]].append(value[1])
            graph[value[1]].append(value[0])
        leaves = []
        new_leaves = []
        for key, value in graph.items():
            if len(value) == 1:
                leaves.append(key)
        while n > 2:
            n -= len(leaves)
            for leaf in leaves:
                leaf_value = graph.get(leaf)[0]
                leaf_set = graph.get(leaf_value)
                leaf_set.remove(leaf)
                if len(leaf_set) == 1:
                    new_leaves.append(leaf_value)
            leaves.clear()
            leaves.extend(new_leaves)
            new_leaves.clear()
        return leaves
    return [0]
```

### 计算n的阶乘的尾数有多少个0
> 如题

**思路**

首先要明确一点就是只有出现5才有可能凑出来0
比如101的阶乘
那么从1到101

`
1,2,3,4,5,6,7,8.....101
`

中间5的个数就是101除以5那么多
101/5=20

`
5,10,15,20,25.....100
`

咱然后就是要注意在这些5的倍数里面有的数是5*5迭代起来的
比如25可以写成5*5，这就增加了5的个数
所以说，在选出的20个数字里面还要再选能整除5的。原理和从101里面选能整除5的一样，用20/5=4

`
25,50,75,100
`

然后继续这个过程，4/5=0
说明没有5*5*5的数字了
最后结果就是
20+4=24

所以做法就是反复除5，直到除到0为止

**代码**

```python
def trailing_zeroes(n):
    """
    :type n: int
    :rtype: int
    """
    res = 0
    while n > 0:
        n //= 5
        res += n
    return res
```

### 加油站问题
>如下

 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油

开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油

开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油

开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油

开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油

开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。

因此，3 可为起始索引。


**思路**

暴力求解复杂度太高
这个题的关键在于排除无效解
有两个情况是可以排除的无效解

1. gas[i]<cost[i]，说明不能从这个点开始遇到的话直接跳过
2. 如果 i到j 失败了，那么从 i+1 到 j， i+2 到 j......j-1 到 j 也一定都是失败的无效解。直接从j位置向后继续遍历即可

满足上述两个条件，只需要遍历一次数组就可以得到解
时间复杂度O(n)

**代码**

```python
def can_complete_circuit(gas, cost):
    """
    :type gas: List[int]
    :type cost: List[int]
    :rtype: int
    """
    index = 0
    gas_len = len(gas)
    while index < gas_len:
        if gas[index] - cost[index] < 0:
            index += 1
        else:
            start = index
            count = gas[start]
            while count - cost[index % gas_len] >= 0:
                count -= cost[index % gas_len]
                count += gas[(index + 1) % gas_len]
                index += 1
                if index % gas_len == start:
                    return start
    return -1
```

### 整数拆分
> 给定一个整数，拆成若干相加的形式，找出最大的乘积的形式
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
36最大

**思路**
首先明确一个问题就是1到4拆出来的结果一定小于等于本身

`
2 -> 1
`

`
3 -> 2
`

`
4 -> 4
`

从5之后就会大于本身。所以任何大于4的数字一定是拆成2,3,4的组合的

其中，拆出的项应该是3经可能的多（数学逻辑。。。。。）
所以就是1个2，剩下全是3
或者1个4，剩下全是3

**代码**

```python
def integer_break(n):
    """
    :type n: int
    :rtype: int
    """
    if n == 2 or n == 3:
        if n == 2:
            return 1
        else:
            return 2
    else:
        if n % 3 == 0:
            i = n / 3
            res = 3 ** i
        elif n % 3 == 1:
            i = (n - 4) / 3
            res = 4 * 3 ** i
        else:
            i = (n - 2) / 3
            res = 2 * 3 ** i
    return int(res)
```

### 打家劫舍1
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
     
>输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


**思路**

很基础的动态规划问题

`
dp[0] = nums[0]
`

`
dp[1] = max(nums[0],nums[1])
`

第i个值分两个情况
- 要这个值，和dp[i-2]结合
- 不要这个值，当前值等于dp[i-1]
比较出max来

所以

`
dp[i] = max(dp[i-1],nums[i]+dp[i-2])
`

最后一个元素就是答案

**代码**

```kotlin
fun rob(nums: IntArray): Int {
    if (nums.isEmpty()) {
        return 0
    }
    if (nums.size == 1) {
        return nums[0]
    }
    val dp = IntArray(nums.size)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[0], nums[1])
    for (i in 2 until nums.size) {
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
    }
    return dp[dp.size - 1]
}
```

### 打家劫舍2
>和1的情况差不多，但是首尾是相通的。选了最后一个就不能选第一个了

**思路**

举个例子
[a,b,c,d,e]
如果包含a有哪些可能的解呢？
只可能是
- [a,c]
- [a,d]
包含a的解一定包含在从0到length-2的dp解（见1）
再看不包含a的解
- [b,d]
- [b,e]
- [c,e]
同理，是从1到length-1的dp的解
两次dp求解即可

**代码**

```kotlin
fun rob(nums: IntArray): Int {
    if (nums.isEmpty()) {
        return 0
    }
    if (nums.size == 1) {
        return nums[0]
    }
    if (nums.size == 2) {
        return Math.max(nums[0], nums[1])
    }
    val dp = IntArray(nums.size)
    return Math.max(rob(nums, 0, dp.size - 1, dp), rob(nums, 1, dp.size, dp))
}

private fun rob(nums: IntArray, start: Int, end: Int, dp: IntArray): Int {
    dp[start] = nums[start]
    dp[start + 1] = Math.max(nums[start], nums[start + 1])
    for (i in start + 2 until end) {
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
    }
    return dp[end - 1]
}

```

### 实现除法
> 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

**思路**
还是先抽象问题

`
M = n * m
`

现在要求n
n可能为任何一个整数，所以n可以表示为2的x次的相加解

`
n = 2^{x1}+2^{x2}+.......2^{xn}
`

所以这个题可以通过左移运算来实现

`
m << x = m * 2^x 
`

首先不断迭代，迭代出来最大的指数值
就是到

`
m<<x = m*2^x > M
`

那么n一定是小于2^x的，毫无疑问
然后x到0倒过来遍历，加上不超过M就加上

`
M = m*2^{x-1}+m*2^{x-2}.....
`

每加一次，还需要统计出来加了多少次
比如现在加上了m<<4 = m * 2^4
那么相当于加了2^4个m
可以用公式

`
2^n = 1 << n
`

最后注意符号的问题就可以了

**代码**

```kotlin
fun divide(dividend: Int, divisor: Int): Int {
    if (dividend == 0) {
        return 0
    }
    if (dividend == Integer.MIN_VALUE && divisor == -1) {
        return Integer.MAX_VALUE
    }
    var signal = false
    if (divisor < 0 && dividend > 0 || divisor > 0 && dividend < 0) {
        signal = true
    }
    val a = Math.abs(dividend.toLong())
    val b = Math.abs(divisor.toLong())
    var i = 0
    while (b shl i <= a) {
        i++
    }
    i--
    var sum = 0L
    var result = 0
    for (value in i downTo 0) {
        if (sum + (b shl value) <= a) {
            sum += b shl value
            result += 1 shl value
        }
    }
    return if (signal) -result else result
}
```