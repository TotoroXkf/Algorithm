### 删除赚钱问题
> 给定一个数组，每一次可以删除一个元素num[i]，并且赚取到num[i]的数量。但是同时所有的num[i]+1和num[i]-1都不能再被选择。问能得到最多的钱是多少?

**思路**

动态规划问题

先排序，然后遍历数组

如果要选取当前数字，那么就以为着放弃前面一位数字（如果是连着的话）。所以

` dp[k] = dp[k-1]+now `

反之，放弃当前数字，就意味着当前值等于前一个的值

` dp[k] = dp[k-1]`

现在要选大的，所以

`
dp[k]=max\{dp[k-2]+now,dp[k-1]\}
`

如果当前数字和之前的完全不项连，那么直接

`
dp[k] = dp[k-1]+now
`

dp数组的最后元素就是解

**代码**

```python
def delete_and_earn(array):
    """
    :type array:list
    :rtype :int
    """
    if array:
        array.sort()
        i = -1
        j = 0
        k = -1
        dp = []
        while j < len(array):
            count = array[j]
            while j + 1 < len(array) and array[j] == array[j + 1]:
                j += 1
                count += array[j]
            if len(dp) == 0:
                dp.append(count)
            else:
                if array[i] + 1 == array[j]:
                    if k == 0:
                        dp.append(max(dp[k], count))
                    else:
                        dp.append(max(dp[k - 1] + count, dp[k]))
                else:
                    dp.append(dp[k] + count)
            k += 1
            i = j
            j += 1
        return dp[-1]
    return 0
```

