### 字符串的是否由两个字符串交错组成
>str1="AB"，str2="12"。那么"AB12"、"A1B2"、"A12B"、"1A2B"和"1AB2"等都是str1和str2的交错组成。给出一个target，判断是不是交错组成的

**思路**

双字符串问题，还是二维的动态规划

如果要匹配target
target的长度应该等于str1和str2

而且target的字符都来自str1和来自str2
并且还要按照相对顺序

比如str1中是ABC，taget就不能出现C...B...A这样的顺序，只能是A...B....C
dp[i][j] 表示str1的前i个和str2的j个字符能不能交错组成target的从开始位置到i+j的子串

boolean类型的二维数组

还是在行和类额外添加一行一列统一操作

假设
target=A1B2E
str1 = 12
str2 = ABE

| Row/Col      | "" |  A |   B   |  E  |
| -------- | --------| ------ |------|-----|
| ""   | true   |    |
|1|||
|2|||



dp[0][0]一定为true
然后看第一行，表示不用str1，只用str2能匹配的程度
那么必须是每一位都相同才可以

target = A1B2E

只有第一个字符是合适的，B和1不匹配。后面的不用再看了 
同理，对列一样的操作

| Row/Col      | "" |  A |   B   |  E  |
| -------- | --------| ------ |--------| --------| 
| ""   | true   |   true |false|false|
|1|false||
|2|false||

现在讨论i，j的一般情况

现在到了(1,1)

str1对应的字符为1
str2对应的字符为A

前面说过了，target的字符一定来自于str1或者str2
那么，到这里，i+j =2，说明要匹配2长度的target

那么现在就是看target的第二个字符是来源于str1还是str2

dp[i-1][j]表示了str1放弃当前字符的情况，为true，说明不看str1的字符，可以匹配之前的情况。那么只要str1的当前字符和target的第二个字符相同就说明这个字符来自于str1，并且这个位置为true

同样的，也可以是dp[i][j-1]，原理是一样的，看看是不是来自于str2的

`
dp[i-1][j] = true
`

`
dp[i][j] = target[i+j-1] == str1[i-1]
`

`
dp[i][j-1] = true
`

`
dp[i][j] = target[i+j-1] == str2[j-1]
`

| Row/Col      | "" |  A |   B   |  E  |
| -------- | --------| ------ | -------- | --------|
| ""   | true   |   true |false|false|
|1|false|true|true|false|
|2|false|false|true|true|

最后一个值就是解

同样的，dp值之和左面的和上面的值有关所以用一维的数组也可以实现代替dp的每一行滚动即可

`
dp[j] = dp[j - 1] &&(col[j - 1] == target[i + j - 1])
`

或者

`
dp[j] = dp[j] && (row[i - 1] == target[i + j - 1])
`



**代码**
```kotlin
fun isCross(str1: String, str2: String, target: String): Boolean {
    if (target.length != str1.length + str2.length) {
        return false
    }
    val row = if (str1.length > str2.length) str1 else str2
    val col = if (str1.length > str2.length) str2 else str1
    val dp = BooleanArray(col.length + 1)
    dp[0] = true
    for (i in 1..col.length) {
        if (col[i - 1] == target[i - 1]) {
            dp[i] = true
        } else {
            break
        }
    }
    for (i in 1..row.length) {
        dp[0] = dp[0] && (row[i - 1] == target[i - 1])
        for (j in 1..col.length) {
            dp[j] = (dp[j - 1] && col[j - 1] == target[i + j - 1]) || (dp[j] && row[i - 1] == target[i + j - 1])
        }
    }
    return dp.last()
}
```