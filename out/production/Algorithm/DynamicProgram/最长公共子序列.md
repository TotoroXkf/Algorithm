### 最长公共子序列
> 给定两个字符串str1和str2，返回两个字符串的最长公共子序列。
> 例如：
str1="1A2C3D4B56"，str2="B1D23CA45B6A"。"123456"或者"12C4B6"都是最长公共子序列，返回哪一个都行。

**思路**

经典的动态规划问题
按照两个字符串列出二维的dp数组。额外增加一列一行使得操作统一

dp[i][j]表示str1[i]和str2[j]的匹配长度
`
dp[0][j] = 0
`
`
dp[i][0] = 0
`
假设遇到i，j位置了
那么匹配当前的情况就是
- str1不看当前字符，看看匹配的长度。也就是dp[i-1][j]
- str2不看当前的字符，看看匹配的长度。也就是dp[i][j-1]
- 两个都看当前的字符，如果str1[i] == str2[j] ，说明当前字符相等，长度可能是前面一个字符匹配长度+1。dp[i-1][j-1]+1

`
dp[i][j] = max(dp[i-1][j],dp[i][j-1])
` 

`
if (str1[i] == str2[j])
`

`
dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)
`

得到了dp数组之后，要想得到字符串，需要倒着重复这个dp求解的过程
从dp数组的最后一个元素开始
等于dp[i-1][j] 就向上走
等于dp[i][j-1]就向左走
不然就向左上方走。向左上方走说明当前这个字符是两个字符串的公共字符，记录下来

最后返回结果即可

**代码**

```kotlin
fun getMaxLenCommon(str1: String, str2: String): String {
    if (str1.isEmpty() || str2.isEmpty()) {
        return ""
    }
    val dp = getDp(str1, str2)
    var i = dp.lastIndex
    var j = dp[0].lastIndex
    val res = CharArray(dp.last().last())
    var index = res.lastIndex
    while (dp[i][j] != 0) {
        when {
            dp[i][j] == dp[i - 1][j] -> i--
            dp[i][j] == dp[i][j - 1] -> j--
            else -> {
                res[index--] = str1[i - 1]
                i--
                j--
            }
        }
    }
    return String(res)
}

fun getDp(str1: String, str2: String): Array<IntArray> {
    val dp = Array(str1.length + 1) { IntArray(str2.length + 1) }
    for (i in 1 until dp.size) {
        for (j in 1 until dp[0].size) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)
            }
        }
    }
    return dp
}
```