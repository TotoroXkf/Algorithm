### 编辑距离
>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
>可以对一个单词进行如下三种操作：
>插入一个字符
>
>删除一个字符
>
>替换一个字符
>输入: word1 = "horse", word2 = "ros"
>
>输出: 3
>解释: 
>
>horse -> rorse (将 'h' 替换为 'r')
>
>rorse -> rose (删除 'r')
>
>rose -> ros (删除 'e')
>
>输入: word1 = "intention", word2 = "execution"
>
>输出: 5
>
>解释: 
>
>intention -> inention (删除 't')
>
>inention -> enention (将 'i' 替换为 'e')
>
>enention -> exention (将 'n' 替换为 'x')
>
>exention -> exection (将 'n' 替换为 'c')
>
>exection -> execution (插入 'u')

**思路**

编辑距离。经典DP问题

首先定义dp函数。dp(i,j) 代表了第一个字符串从0到i位的子串和第二个字符串从0到j位的子串的最小编辑距离

那么dp(i,0) = i  (abc和"",想要变得相同，abc有几位就是几下变动)  dp(0,j) = j

当前dp的值等于3种情况中小的那个

- 第一个子字符串不算最后i那个字符，剩下的字符串和第二个子字符串的编辑距离加1.(也好理解。第一个字符串不算最后一个，第二个字符串变成剩下的字符串之后，删掉第i个字符就可以)
- 第二个子字符串不算最后j那个字符，剩下的字符串和第一个子字符串的编辑距离加1.原因同上
- 两个字符串同时不算最后一个。得到剩下的两个字符串的编辑距离，然后看不算的那两个字符串是不是相同，相同说名之前的编辑距离就是算是他两的编辑距离。不同再加1。因为要把他两变成一样的


那么状态转移方程

`
dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]/(dp[i-1][j-1]+1))
`

二维的dp数组。构建出来之后，最后一个元素就是解

```kotlin
fun minDistance(word1: String, word2: String): Int {
    val dp = Array(word2.length + 1) { IntArray(word1.length + 1) }
    for (i in dp.indices) {
        for (j in 0 until dp[i].size) {
            when {
                i == 0 -> dp[0][j] = j
                j == 0 -> dp[i][0] = i
                else -> {
                    var value = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
                    value = if (word1[j - 1] == word2[i - 1]) {
                        Math.min(value, dp[i - 1][j - 1])
                    } else {
                        Math.min(value, dp[i - 1][j - 1] + 1)
                    }
                    dp[i][j] = value
                }
            }
        }
    }
    return dp.last().last()
}
```