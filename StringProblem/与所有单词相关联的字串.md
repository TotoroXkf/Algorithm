# 与所有单词相关联的字串
> 给定一个字符串 s 和一些长度相同的单词 words。在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。  
> 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

>示例 1:  
输入:  
s = "barfoothefoobarman"  
words = ["foo","bar"]  
输出: [0,9]  
解释: 从索引 0 和 9 开始的子串分别是 "barfoor" 和 "foobar" 。  
输出的顺序不重要, [9,0] 也是有效答案。  

>示例 2:  
输入:  
s = "wordgoodstudentgoodword"  
words = ["word","student"]  
输出: []

> 注意:  
> s = "barfoobar"    
> words = ["foo","bar"]  
> barfoo 成立，答案是0  
> foobar也成立，答案是3  
> 应该返回[0,3]。foo在中金是可被复用的

**思路**
--------------------

这个题同时考验了coding能力和分析能力，不过这个题目的确有那么点智障。。。。

**首先抓住这个题目的关键点，每个单词的长度是相同的。**。所以说我们可以把这个字符串拆分成为相同长度的单词的组合

比如s = "barfoothefoobarman"。words = ["foo","bar"]这个例子，单词长度为3。我们可以把s看作为  
`bar foo the foo bar man`  
然后通过map去匹配出现的次数来判断是不是成立。初始化dict为{foo:1,bar:1}  
同时维护一个临时的dict。遇到第一个单词bar，存在于单词dict中，就放如零时dict，bar:1。再往后遇到foo，同样操作放入零时dict。foo:1.  
每一次放入零时dict的时候都要记下来已经连续成功放入多少个单词了。放入foo的时候等于放入了2个单词，和总单词数相同，就给记录bar起始的位置。  
上面这个操作已经不容易实现了。所以说是同时考验coding能力  

上面只是一部分。把字符串切割为单词是有多种情况的。但是情况的总数是等于一个单词的长度的。每次抛弃一个字母。"barfoothefoobarman"可拆分的情况是3种  
`bar foo the foo bar man`   
`arf oot hef oob arm an`   
`rfo oth efo oba rma n`   
如果再往后的切割形式都是包含在上面的。不做考虑

对每一种都要处理，是上面的过程。

这还有两个细节需要处理，就是删除重复单词。  
- 比如"foo foo bar" words=[foo,bar]。在遍历到前面两个单词的时候foo加为2。当零时dict里面值大于原本dict时，应该逐步删除前面的单词。比如这里就是删除foo的出现次数。减去1，丢掉第一个foo。如果foo之前还有单词，都应该删除。因为他们的重复导致了后面的都会无效，必须丢弃
- 单词复用的问题。其实就是上面的思路。比如s = "barfoobar"。words =["foo","bar"]。当bar foo 都判定成功，记录答案0的时候，不应该丢球这两个单词的出现次数，而是继续向后。再次遇到bar，触发重复删除，删除第一个bar，得到新解，记录3.


**代码**
--------------------

```python
def find_substring(s: str, words: list):
    if not s or words == []:
        return []
    s_length = len(s)
    word_length = len(words[0])
    all_word_length = len(words) * word_length
    result, word_times = [], {}
    for word in words:
        word_times[word] = word_times.setdefault(word, 0) + 1
    for i in range(word_length):
        word_start = i
        cur_map = {}
        for j in range(i, s_length, word_length):
            word = s[j:j + word_length]
            if word not in word_times:
                cur_map.clear()
                word_start = j + word_length
            else:
                cur_map[word] = cur_map.setdefault(word, 0) + 1
                while cur_map[word] > word_times[word]:
                    cur_map[s[word_start:word_start + word_length]] -= 1
                    word_start += word_length
                if j + word_length - word_start == all_word_length:
                    result.append(word_start)
    return result
```