# 最长回文字符串
>找到字符串中最长的回文字符串


**思路**
--------------------

先说一般做法，也就是最常规的以一个字符为中心或者两个字符为中心扩展的做法

遍历字符串，遇到一个字母做两个处理

- 以自身为中点，向左右扩展，左边等于右边就继续。扩展结束得到长度，赋值给start和end
- 判断下一个字符和当前字符是否相等。等于的话，以这两个字母为中心扩展，如上。下一个字符和当前字符不等不处理

中间记录长度和位置即可。时间复杂度为O(n^2)

下面说最优解.时间复杂度O(n)，空间复杂度O(n)

**Manacher’s Algorithm**

原字符串为S。这个办法首先给每个字符串中间插入一个特殊的符号#，生成T字符串。使得字符串不论原来长度奇偶现在一律变为奇数长度  

同时构造一个辅助数组P.P[i]的意义是以T[i]字符为中心的回文字符串的半边的长度。

比如下面这个

`....0 1 2 3 4 5 6 7 8 9 ......`  
`T = # a # b # a # a # b # a #`  
`P = 0 1 0 3 0 1 6 1 0 3 0 1 0`

以T[3]为中心的回文字符串左边长度为3，右边长度为3。由于T字符串其实是S字符串的长度两倍，所以P[i]的另外一层含义是以T[i]为中心的，S中的最长回文字符串的长度。T[3]=b，在S中以这个字符为中心的最长回文字符串也就是3

这个做法很巧妙。它在中间插入#使得不用以两个字符为中心扩展，只用一个字符为中心扩展。非常优雅

现在考虑怎么构建这个P[i].

![image](https://articles.leetcode.com/wp-content/uploads/2011/11/palindrome_table10.png)

我们就先假设前面的都求出来了。然后求p[13]的值。再处理时，维护一个中心C和一个右边界R。当i落在[C,R]之间的范围时，可以这么分析

C时回文字符串的中心。i在C的右侧，可以求出来i关于C的对称位置j.这个计算很容易。j=2*C-i。  
然后我们看看p[j]的位置多大。p[j]现在等于1，说明以j为中心能扩展1长度的回文串。  
`T[j-1]=T[j+1]`  
由于C是一个长回文串的中心，所以  
`T[i]=T[j]`  
`T[j+1]=T[i-1]`    
`T[j-1]=T[i+1]`  
由此必然的得到  
`T[i-1]=T[i+1]`  
所以说以i为中心的回文字符串的长度至少为1，直接继承了P[j]的值。  
还可以在进一步推到得出p[i]不可能大于p[j]，过程和上面类似，一些不等于，就不写了。  
这样一来，就完美的避免了以i，也就是13为中心的字符串向两边扩展的比较，节省了效率。

![image](https://articles.leetcode.com/wp-content/uploads/2011/11/palindrome_table11.png)

再看上面这个过程，p[j]的值比较小，以j为中心的字符串完全落在了以C为中心的字符串里面，所以上面的推到成立。那么p[j]到多大就不合适了？？

这样理解。从i位置到R位置是i位置在C为中心的字符串中最长能扩展的距离了。如果p[j]小于或者等于这个数值，说明p[i]到R之间的扩展都是可以涵盖在以C为中心的这个长字符串中的。就不用再次扩展,p[j]=p[i]  
所以说  
`R-i>=p[i]---->p[i]=p[j]`

那如果R-i<p[j]????  
看下图  

![image](https://articles.leetcode.com/wp-content/uploads/2011/11/palindrome_table4.png)

现在就是这个情况了。按照推到，我们至少可以确定在15到20这个范围里面p[i]都是可以不用扩展的，直接就知道5长度必定是回文的。但是超过了R的话，就没办法知道了，那就只能从R+1开始向后匹配了

![image](https://articles.leetcode.com/wp-content/uploads/2011/11/palindrome_table5.png)

`R-i>=p[i]---->p[i]=(R-i)+x`

这个x就代表了R之后新匹配上的长度

然后再要在构建P的收反复比较最大值，记下位置就可以截取出最长的子串了。  
这个算法的复杂度是O(n),避开了大量的重复比较，非常的了不起

上面说了原理，现在看看代码怎么写  

1. 按照上面的原理，是需要向左右扩展的，所以如果不做处理的话不断向左或者向右很可能越界，可以加if判断，不过更好的办法是在头尾加两个特殊字符，这样扩展到他们就自动匹配不成功了。在开头加个^,在末尾加个@。
2. 扩展字符串成为每两个字符中间都带有#的
3. 开始构建P[i]数组。
    1. 当 R< i 时，没有办法使用上面的算法，使得p[i]=0，然后左右扩展。
    2. 当R > i时.计算出j=2*C-i
        1. 如果R-i >= p[j],p[i]=p[j]
        2. 反之，p[i] = R-i
        3. 可以抽象为p[i] = min(R-i,p[j])
    3. 不论R-i就过如何都应该扩张，这样代码统一。这不违反上面的算法原理，当R-i>=p[j]的时候扩张一次自然就会失败。
    4. 计算完之后跟新R和C。如果新产生的扩张长度i+p[i]大于R，将R移动到新位置。也就是i+p[i],C移动到i位置
    5. 记录最大值和位置
4. 切出子串，返回

算法真的耐人寻味啊

**代码**
--------------------


```python
def longest_palindrome(self, s: str):
    temp = ["^"]
    for c in s:
        temp.append("#" + c)
    temp.append("#@")
    t = "".join(temp)
    p = [0] * len(t)
    c, r = 0, 0
    max_len, position = 0, 0
    for i in range(1, len(t) - 1):
        j = 2 * c - i
        p[i] = 0 if r <= i else min(r - i, p[j])
        while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
            p[i] += 1
        if i + p[i] > r:
            c, r = i, i + p[i]
        if p[i] > max_len:
            max_len = p[i]
            position = i
    start = (position - max_len - 1) // 2
    return s[start:start + max_len]
```