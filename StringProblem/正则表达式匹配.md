# 正则表达式匹配
>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。  

>示例 1:  
输入:  
s = "aa"  
p = "a"  
输出: false  
解释: "a" 无法匹配 "aa" 整个字符串。  

>示例 2:  
输入:  
s = "aa"  
p = "a*"  
输出: true  
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。  

>示例 3:  
输入:  
s = "ab"  
p = ".*"  
输出: true  
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。  

>示例 4:  
输入:  
s = "aab"  
p = "c*a*b"  
输出: true  
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。  

>示例 5:  
输入:  
s = "mississippi"  
p = "mis*is*p*."  
输出: false  


**思路**

两个字符串匹配的各种问题都容易想到使用DP求解
先来分析这个问题的情况
首先，.和一般的字符没有什么不一样的地方

难点就是这个*的问题

还是按照二维dp的解法列出表格
dp[i][j]表示s的i长度和p的j长度是否匹配。
是boolean类型的。这个boolean十分的精髓
看个例子
s = aaaa
p = a*b*
首先能确定就是行和列
从列来看，“”只能匹配“”
从行来看，“”只能匹配*（*可以表示0个字符），而且还要看看dp[i][j-2]是什么。如果dp[i][j-2]是true的表示这里*代表没有字符，前面匹配则这里匹配，前面不匹配则这里不匹配

| .....      | "" | a | * | b | * |
|-----|-----|------|------|------|-------|
| "" | t  |f|t|f|t| 
| a    |f    | 
| a   |  f  | 
| a   |   f |
| a   |   f |  


然后就是中间的内容
先考虑简单的情况，不遇到*

遇到.和遇到一般字符是一样的
这个好说。匹配的话，dp[i][j] = dp[i-1][j-1]
当前匹配就看之前的匹不匹配。前面的匹配现在的就匹配，前面的不匹配，当前的就不匹配
`
s[i] == p[j]
`

`
dp[i][j] = dp[i-1][j-1] 
`

`
s[i] != p[j] && s[i] !="*"
`
`
dp[i][j] = false
`

如果当前遇到的是*的话
- 当前*代表0个字符 那么就看看dp[i][j-2]的值。如果为true，说明代表0个字符是可以匹配的，那么还需要能匹配s[i-1]。就是说当前这个字符已经能匹配了，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]
- 当前*代表1个或多个字符串。这需要看看*前面的字符。s[i]==p[j-1]的话，说明扩展之前的字符可以匹配当前值。同上，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]

所以说

`
dp[i][j-2]=true
`

`
dp[i][j] = dp[i-1][j]
`

`
s[i] = p[j-1]
`

`
dp[i][j] = dp[i-1][j]
`

按照这个规则填充表格

| .....      | "" |a|*|b|*|
| -------- | --------|--------|-------|--------|-------|
|"" | t  |f|t|f|t|
| a | f | t|t|f|t|
| a | f | f|t|f|t|
| a | f |f|t|f|t|
| a | f | f |t|f|t|

最后一个元素就是答案

**代码**

```kotlin
fun isMatch(s: String, p: String): Boolean {
    val m = s.length
    val n = p.length
    val dp = Array(m + 1) { BooleanArray(n + 1) }
    dp[0][0] = true
    for (i in 1..m)
        dp[i][0] = false
    for (j in 1..n)
        dp[0][j] = j > 1 && '*' == p[j - 1] && dp[0][j - 2]
    for (i in 1..m) {
        for (j in 1..n) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]
            } else {
                dp[i][j] = (p[j - 1] == '.' || s[i - 1] == p[j - 1]) && dp[i - 1][j - 1]

            }
        }
    }
    return dp[m][n]
}

```

