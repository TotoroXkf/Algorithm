# 最小覆盖子串
> 给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。   
> 输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"

**思路**
--------------------

相对困难的滑动窗口的问题。

解决的思路很直白，先用dict把所有T字符串中的字符出现次数统计出来。在这个例子中就是{A:1,B:1,C:1}

然后遍历S，当遇到一个字符在dict中时，就说明它是在T中存在的元素。那么就要考虑一下是不是已经凑齐的子串？没有凑齐子串就记下1次，继续向后。如果此时凑齐了子串，就可以统计长度，然后丢弃S中的最左边的一个有效字符。在这个例子中当找到ADOBEC时就凑齐了子串。此时应该丢弃最左侧的A，向后接着找，才可能找到更小的子串。

所以继续向后，当遇到B时可以判断出来时凑不齐子串的，缺少的是A，不是B。但是需要考虑的是，之前的哪个B其实是失效了。后面的这个B才可能构成最小的子串。再往后的操作都一样了，就是找到了BANC

总结下来一句话，枚举所有的符合条件的子串，找最短的那个。

想要实现上面的思路需要不错的coding能力。下面看怎么最好的写出这个代码
- 遍历T统计出现次数
- 遍历S
    - 遇到一个字符就在dict中减去1.如果大于等于0，说明这个字符是在T中存在的，给count+1
    - 当count和T的长度相等时，说明凑齐了子串
        - 计算当前的长度，截取字符串。（一直要维护最左边的有效位置，所以这步很容易）
        - 给最左字符的计数+1，表示抛弃最左边这个字符。按照遍历的逻辑，减去1大于0是才会被再次统计进来，所以现在给它加1，实现了抛弃最左字符的效果
        - 当抛弃最左字符之后向后迭代最左边界值，直到遇到一个计数为0的，这个字符就是新的有效的最左字符串了
        - 上面的两步可以合成一种写法，就是给最左边界字符先+1，在判断大于0即可
- 返回结果

最后还是看着代码理解比较好。比较考验coding和分析能力

**代码**
--------------------

```python
def min_window(s: str, t: str):
    s_size, t_size = len(s), len(t)
    start, count, min_len = 0, 0, 2 ** 31
    result = ""
    char_dict = {}
    for char in t:
        char_dict[char] = char_dict.setdefault(char, 0) + 1
    for i in range(s_size):
        char_dict[s[i]] = char_dict.setdefault(s[i], 0) - 1
        if char_dict[s[i]] >= 0:
            count += 1
        while count == t_size:
            if min_len > i - start + 1:
                min_len = i - start + 1
                result = s[start:start + min_len]
            char_dict[s[start]] += 1
            if char_dict[s[start]] > 0:
                count -= 1
            start += 1
    return result
```
