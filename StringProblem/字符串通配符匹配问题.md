# 字符串通配符问题
- [字符串通配符问题](#字符串通配符问题)
    - [题型1](#题型1)
    - [题型2](#题型2)


## 题型1
>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。  

>示例 1:  
输入:  
s = "aa"  
p = "a"  
输出: false  
解释: "a" 无法匹配 "aa" 整个字符串。  

>示例 2:  
输入:  
s = "aa"  
p = "a*"  
输出: true  
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。  

>示例 3:  
输入:  
s = "ab"  
p = ".*"  
输出: true  
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。  

>示例 4:  
输入:  
s = "aab"  
p = "c*a*b"  
输出: true  
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。  

>示例 5:  
输入:  
s = "mississippi"  
p = "mis*is*p*."  
输出: false  


**思路**
--------------------

两个字符串匹配的各种问题都容易想到使用DP求解
先来分析这个问题的情况
首先，.和一般的字符没有什么不一样的地方

难点就是这个*的问题

还是按照二维dp的解法列出表格
dp[i][j]表示s的i长度和p的j长度是否匹配。
是boolean类型的。这个boolean十分的精髓
看个例子
s = aaaa
p = a*b*
首先能确定就是行和列
从列来看，“”只能匹配“”
从行来看，“”只能匹配*（*可以表示0个字符），而且还要看看dp[i][j-2]是什么。如果dp[i][j-2]是true的表示这里*代表没有字符，前面匹配则这里匹配，前面不匹配则这里不匹配

| ..... | ""  | a   | *   | b   | *   |
| ----- | --- | --- | --- | --- | --- |
| ""    | t   | f   | t   | f   | t   |
| a     | f   |
| a     | f   |
| a     | f   |
| a     | f   |


然后就是中间的内容
先考虑简单的情况，不遇到*

遇到.和遇到一般字符是一样的
这个好说。匹配的话，dp[i][j] = dp[i-1][j-1]
当前匹配就看之前的匹不匹配。前面的匹配现在的就匹配，前面的不匹配，当前的就不匹配
`
s[i] == p[j]
`

`
dp[i][j] = dp[i-1][j-1] 
`

`
s[i] != p[j] && s[i] !="*"
`
`
dp[i][j] = false
`

如果当前遇到的是*的话
- 当前*代表0个字符 那么就看看dp[i][j-2]的值。如果为true，说明代表0个字符是可以匹配的，那么还需要能匹配s[i-1]。就是说当前这个字符已经能匹配了，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]
- 当前*代表1个或多个字符串。这需要看看*前面的字符。s[i]==p[j-1]的话，说明扩展之前的字符可以匹配当前值。同上，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]

所以说

`
dp[i][j-2]=true
`

`
dp[i][j] = dp[i-1][j]
`

`
s[i] = p[j-1]
`

`
dp[i][j] = dp[i-1][j]
`

按照这个规则填充表格

| ..... | ""  | a   | *   | b   | *   |
| ----- | --- | --- | --- | --- | --- |
| ""    | t   | f   | t   | f   | t   |
| a     | f   | t   | t   | f   | t   |
| a     | f   | f   | t   | f   | t   |
| a     | f   | f   | t   | f   | t   |
| a     | f   | f   | t   | f   | t   |

最后一个元素就是答案

**代码**
--------------------

```python
def is_match(s: str, p: str):
    m, n = len(s), len(p)
    dp = [[False for i in range(n + 1)] for j in range(m + 1)]
    dp[0][0] = True
    for i in range(1, m + 1):
        dp[i][0] = False
    for j in range(1, n + 1):
        dp[0][j] = j > 1 and '*' == p[j - 1] and dp[0][j - 2]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j]
            else:
                dp[i][j] = (p[j - 1] == '.' or s[i - 1] == p[j - 1]) and dp[i - 1][j - 1]
    return dp[-1][-1]
```



## 题型2
> 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配  
'?' 可以匹配任何单个字符。  
'*' 可以匹配任意字符串（包括空字符串）。  
两个字符串完全匹配才算匹配成功。  

>示例 1:  
输入:  
s = "aa"  
p = "a"  
输出: false  
解释: "a" 无法匹配 "aa" 整个字符串。  

>示例 2:  
输入:  
s = "aa"  
p = "*"  
输出: true  
解释: '*' 可以匹配任意字符串。  

>示例 3:  
输入:  
s = "cb"  
p = "?a"  
输出: false  
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。  

>示例 4:  
输入:  
s = "adceb"  
p = "*a*b"  
输出: true  
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".  

>示例 5:   
输入:  
s = "acdcb"  
p = "a*c?b"  
输入: false  


**思路**
--------------------

这个题可以和上面的题思路一样，就是使用二维动态规划解答。但是这道题稍微特殊，所以动态规划反而不是最优解

仔细分析题目，这个题目启示就是要看*能匹配多少个字符，仅此而已。  
所以做法就是，同时遍历两个字符串：
- 当字符两个字符相同，或者p的字符为？，继续向后
- 如果p的字符为*
    - 记下这个*的位置，和此时s字符的位置，然后慢慢尝试，让 * 先匹配0个字符，然后向后继续。如果遇到不匹配的，回到p记录的位置+1，然后让记录的s位置向前移动一位，表示它被 *匹配了。等于说是让 *匹配一位，然后u在继续向后
        - 如果=又遇到了一个*号，说名前面这个 *号完成了之前的所有匹配，则刷新记录位置继续即可
- 当完全遍历完，如果p字符停留在中间的位置，说明p字符只用部分就成功的匹配了s字符，则看p后面是不是全部都是*，只要有一个不是就返回False

**代码**
--------------------

```python
def is_match(s: str, p: str):
    s_len, p_len = len(s), len(p)
    i, j = 0, 0
    cover_s, start = 0, -1
    while i < s_len:
        if j < p_len and (s[i] == p[j] or p[j] == '?'):
            i, j = i + 1, j + 1
        elif j < len(p) and p[j] == '*':
            start = j
            cover_s = i
            j += 1
        elif start != -1:
            cover_s += 1
            i = cover_s
            j = start + 1
        else:
            return False
    while j < p_len and p[j] == '*':
        j += 1
    return j == p_len
```

