# 二叉树的非递归遍历
- [二叉树的非递归遍历](#二叉树的非递归遍历)
    - [前序遍历](#前序遍历)
    - [中序遍历](#中序遍历)
    - [后序遍历](#后序遍历)


## 前序遍历
> 非递归前序遍历

**思路**

抓住前序遍历的特点就很好写了。前序遍历是遍历到一个节点就输出这个节点。所以完全可以生成一个遍历的序列，让每次输出即可

刚开始栈里放一个root

每次遍历到一个节点，出栈，然后左边节点先输出，右边节点后输出，所以右边先入栈，左边后入栈。对每一个节点都如此操作就生成了相应的顺序。加上栈先入后出的特性就是实现了递归的效果

**代码**
```python
def pre_order_traversal(root: TreeNode):
    if root is None:
        return []
    stack, result = [root], []
    while stack:
        node = stack.pop(-1)
        result.append(node.val)
        if node.right is not None:
            stack.append(node.right)
        if node.left is not None:
            stack.append(node.left)
    return result
```


## 中序遍历
> 非递归前序遍历

**思路**
还是用栈

对于中序的每个节点作如下考虑
- 如果是从上往下遍历时遇到的，并且左节点不为None，那么就入栈左节点。
- 如果是回朔到这个节点的，输出，然后把这个节点出栈。右节点不为None就入栈右节点。

判断是不是回朔回来的方法就是设置一个变量即可。这样就模仿了递归的操作

**代码**
```python
def in_order_traversal(root: TreeNode):
    if root is None:
        return []
    stack, result = [root], []
    back = False
    while stack:
        node = stack[-1]
        if not back and node.left is not None:
            stack.append(node.left)
        elif back or node.left is None:
            result.append(node.val)
            parent = stack.pop()
            back = True
            if parent.right is not None:
                stack.append(parent.right)
                back = False
    return result
```

## 后序遍历
> 非递归前序遍历

**思路**

**代码**

