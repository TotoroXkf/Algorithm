### 数组的小和
>数组小和的定义如下：
>例如，数组s=[1，3，5，2，4，6]，在s[0]的左边小于或等于s[0]的数的和为0，在s[1]的左边小于或等于s[1]的数的和为1，在s[2]的左边小于或等于s[2]的数的和为1+3=4，在s[3]的左边小于或等于s[3]的数的和为1，在s[4]的左边小于或等于s[4]的数的和为1+3+2=6，在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15，所以s的小和为0+1+4+1+6+15=27。
>给定一个数组s，实现函数返回s的小和。

**思路**

比较难想到办法的一个题
最优解是归并思路的办法（也不知道是怎么想到的。。。。）

`
[a,b,c,d,e,f]
`

我们假设a，b，c有序，d，e，f有序
但是整体无序
然后按照归并排序的做法
比较a和d
如果

`
d \geq a
`

必然有

`
f\geq e \geq d  \geq a
`

所以，对于元素d，e，f来说，在计算小和的时候也是要加a的
所以此时直接加上

`
sum+=a*len(d.....f)
`
 
那如果反过来，a>d，说明d的小和不加a，后面的不知道，往后走的时候自然直到
所以，a>d，不处理结果，继续归并即可
不论是左半数组遍历结束还是右半数组遍历结束，说明整体的小和都加完了，剩下的直接放入数组即可
如此归并下去，每一次合并都是在榨出当前这个区间的小和，最后整体的也会榨出来
这个题使用归并的精妙之处在于左半数组和右半数组保持了相对的位置
可能abc的位置在归并的时候发生了变化，但是到这一步，a和d的相对位置并没有发生改变， a还是在d的前面，a，b，c的位置无关紧要了
而abc的位置在归并abc的时候又保持了相对位置，重复了这个过程
真的精彩！



**代码**

```kotlin
fun getSmallSum(array: IntArray): Int {
    if (array.isEmpty()) {
        return 0
    }
    return getSmallSum(array, 0, array.size - 1)
}

fun getSmallSum(array: IntArray, left: Int, right: Int): Int {
    if (left == right) {
        return 0
    }
    val mid = (left + right) / 2
    val leftResult = getSmallSum(array, left, mid)
    val rightResult = getSmallSum(array, mid + 1, right)
    val result = merge(array, left, mid, right)
    return result + leftResult + rightResult
}

fun merge(array: IntArray, left: Int, mid: Int, right: Int): Int {
    if (left == right) {
        return 0
    }
    val temp = IntArray(right - left + 1)
    var i = left
    var j = mid + 1
    var index = 0
    var sum = 0
    while (i <= mid || j <= right) {
        if (i > mid || (j <= right && array[i] > array[j])) {
            temp[index++] = array[j++]
        } else {
            if (i <= mid && j <= right) {
                sum += ((right - j + 1) * array[i])
            }
            temp[index++] = array[i++]
        }
    }
    index = left
    for (value in temp) {
        array[index++] = value
    }
    return sum
}
```

