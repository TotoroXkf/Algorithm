###  正则表达式匹配
>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
示例 1:

>输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

>输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
示例 3:

>输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
示例 4:

>输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
示例 5:

>输入:
s = "mississippi"
p = "mis*is*p*."
输出: false


**思路**

两个字符串匹配的各种问题都容易想到使用DP求解
先来分析这个问题的情况
首先，.和一般的字符没有什么不一样的地方

难点就是这个*的问题

还是按照二维dp的解法列出表格
dp[i][j]表示s的i长度和p的j长度是否匹配。
是boolean类型的。这个boolean十分的精髓
看个例子
s = aaaa
p = a*b*
首先能确定就是行和列
从列来看，“”只能匹配“”
从行来看，“”只能匹配*（*可以表示0个字符），而且还要看看dp[i][j-2]是什么。如果dp[i][j-2]是true的表示这里*代表没有字符，前面匹配则这里匹配，前面不匹配则这里不匹配
| .....      | "" |a|*|b|*|
| -------- | --------|-------|-------|----------|---------|
| “” | t  |f|t|f|t| 
| a    |f    | 
| a   |  f  | 
| a   |   f |
| a   |   f |  

然后就是中间的内容
先考虑简单的情况，不遇到*

遇到.和遇到一般字符是一样的
这个好说。匹配的话，dp[i][j] = dp[i-1][j-1]
当前匹配就看之前的匹不匹配。前面的匹配现在的就匹配，前面的不匹配，当前的就不匹配
`
s[i] == p[j]
`

`
dp[i][j] = dp[i-1][j-1] 
`

`
s[i] != p[j]  \&\& s[i] !="*"
`
`
dp[i][j] = false
`

如果当前遇到的是*的话
- 当前*代表0个字符 那么就看看dp[i][j-2]的值。如果为true，说明代表0个字符是可以匹配的，那么还需要能匹配s[i-1]。就是说当前这个字符已经能匹配了，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]
- 当前*代表1个或多个字符串。这需要看看*前面的字符。s[i]==p[j-1]的话，说明扩展之前的字符可以匹配当前值。同上，还要能匹配不算这个字符的前面的字符串。就是dp[i-1][j]

所以说

`
dp[i][j-2]=true
`

`
dp[i][j] = dp[i-1][j]
`

`
s[i] = p[j-1]
`

`
dp[i][j] = dp[i-1][j]
`

按照这个规则填充表格
| .....      | "" |a|*|b|*|
| -------- | --------|--------|-------|--------|-------|
|"" | t  |f|t|f|t|
| a | f | t|t|f|t|
| a | f | f|t|f|t|
| a | f |f|t|f|t|
| a | f | f |t|f|t|

最后一个元素就是答案

**代码**

```kotlin
fun isMatch(s: String, p: String): Boolean {
    val m = s.length
    val n = p.length
    val dp = Array(m + 1) { BooleanArray(n + 1) }
    dp[0][0] = true
    for (i in 1..m)
        dp[i][0] = false
    for (j in 1..n)
        dp[0][j] = j > 1 && '*' == p[j - 1] && dp[0][j - 2]
    for (i in 1..m) {
        for (j in 1..n) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]
            } else {
                dp[i][j] = (p[j - 1] == '.' || s[i - 1] == p[j - 1]) && dp[i - 1][j - 1]

            }
        }
    }
    return dp[m][n]
}

```

### KMP算法
>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

**思路**


经典字符串匹配算法KMP
首先假设有一个needle字符串

`
abcdefghi
`

`
abc = fgh
`

当i字符不匹配的时候直接比较 haystack的当前字符和d字符就可以了.因为i字符不匹配，说明abcdefgh都是匹配的.同时abc = fgh.所以i之前的3个字符直接就是等于haystack当前位置的前3个字符的.所以直接比较haystack的当前字符和d字符就可以了

现在问题就是，如何知道一个字符串的最长前缀和后缀呢？

就像abc和fgh这样的

这时可以构建一个数组记录每一个位置的最长前缀和后缀的匹配情况

和这个数组叫next

**next[i]表示当i个字符不匹配时，从0到i-1的最长前缀和后缀**

next[0]不存在，就是-1了

next[1]就是0

当1位置的字符不匹配，前面只有一个字符，所以next[1] = 0

|  a   |  a  |   c   |  a  |  a  |  a  |  c  |  a  |  i  |
| -------- | --------| ------ |-------|-------|--------|----------|----------|---------|
|  -1  |  0  |     |

然后从1位置开始遍历
next[1] = 0

所以之前有0个匹配的前缀后缀

那么只能让a和0位置比较了
相等，说明从0到1有1个前缀相同

那么next[2] = 1
再往后，next[2] = 1
说明之前有1个前缀匹配

看这个情况

`
ax....ay
`

之前有1个匹配，那么就从1位置，也就是第二个字符开始比较匹配即可

也就是用ax比较ay

看看能不能比较出来两个长度
所以此时比较needle[i]和needle[next[i]]
c!=a

继续这个过程比较needle[i]和needle[next[i]]，直到匹配到0位置（为什么之后在说）
执行这个过程就可以
|  a   |  a  |   c   |  a  |  a  |  a  |  c  |  a  |  i  |
| -------- | --------| ------ |-------|-------|--------|----------|----------|---------|
|  -1  |  0  |  1  |  0  |  1  |  2  |  2  |  3  |  4  |
现在来说为什么会是重复那个过程得到解

aac太短，看aacaaa这个子串
现在到到了aacaaa的位置
|  a   |  a  |   c   |  a  |  a  |  a  |  c  |  a  |  i  |
| -------- | --------| ------ |-------|-------|--------|----------|----------|---------|
|  -1  |  0  |  1  |  0  |  1  |  2  |    |    |    |

next 此时 = 2

说明之前是有2个匹配的前后缀
那么让当前字符a和第3个比较

a!=c

此时c对应的next的值是1
这个是关键，说明c之前还有1个匹配前后缀

抽象一下
假设字符串

`
abcde
`

`
ab = de
`

`
a=d,b=e
`

之前的又有1个匹配前后缀

`
a =b
`

所以

`
a = e
`

那么e后面的一个字符完全可以和b在比较，可能构建出来ab = ex的情况
这就是为什么还要重复那个过程的原因，直到0

总结下来，构建next数组
- next[0]不存在，就是-1
- next[1]是0
- 重复比较，j=next[i],needle[i]和needle[next[j]]。得到next[i]

有了数组之后，匹配字符串，不匹配的时候移动到next指定的位置，反复比较，就可以了

**代码**

```kotlin
fun strStr(haystack: String, needle: String): Int {
    if (haystack.isEmpty() && needle.isEmpty())
        return 0
    else if (haystack.isEmpty())
        return -1
    else if (needle.isEmpty()) return 0
    val next = getNext(needle)
    var i = 0
    var j = 0
    while (i < haystack.length && j < needle.length) {
        if (j == -1 || haystack[i] == needle[j]) {
            i++
            j++
        } else {
            j = next[j]
        }
    }
    return if (j == needle.length) {
        i - needle.length
    } else -1
}

private fun getNext(needle: String): IntArray {
    val next = IntArray(needle.length)
    var j = -1
    var i = 0
    next[i] = -1
    while (i < needle.length - 1) {
        if (j == -1 || needle[i] == needle[j]) {
            j++
            i++
            next[i] = j
        } else {
            j = next[j]
        }
    }
    return next
}
```

### 最长无重复子字符串
> 输入: "abcabcbb"
输出: 3 
解释: 无重复字符的最长子串是 "abc"，其长度为 3。

**思路**

维护一个窗口，窗口内的都是没有重复字符串的子串
利用hashmap保存字符出现的位置

不断向后扩展窗口，当遇到了一个字符，hashmap包含了它说明重复，只需要取出对应字符出现的位置，然后让窗口左边界移动到这个位置，就可以过滤掉重复字符和重复字符之前的所有字符
随后向右继续扩展窗口即可

**代码**

```kotlin
fun lengthOfLongestSubstring(s: String): Int {
    val n = s.length
    var ans = 0
    val map = HashMap<Char, Int>()
    var j = 0
    var i = 0
    while (j < n) {
        if (map.containsKey(s[j])) {
            i = Math.max(map[s[j]]!!, i)
        }
        ans = Math.max(ans, j - i + 1)
        map[s[j]] = j + 1
        j++
    }
    return ans
}
```