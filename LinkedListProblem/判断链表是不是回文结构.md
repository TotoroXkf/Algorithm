# 判断链表是不是回文结构
>如题

**思路**

这个题看允不允许改变原链表的结构了。

如果不允许改变链表的结构的话，那么使用栈可以很好的解决这个问题。  
使用栈不断压入元素。然后再次遍历链表，和栈中的元素比较，等于每次比较头和尾，就能判断出来时候是回文结构

如果允许改变链表的结构，可以确定中间节点，然后翻转中间节点到末尾的节点，同时记录下来尾节点，从尾节点和头节点向中间靠近，同时判断是否相同即可。

比较两种方法,第二种可以省下空间.但是需要改变链表结构

**代码**
```python
# 不允许改变链表的结构
def is_palindrome(head: ListNode):
	stack = []
	node = head
	while node is not None:
		stack.append(node.val)
		node = node.next
	node = head
	while stack and node is not None:
		if stack.pop(-1) != node.val:
			return False
		node = node.next
	return True
```

```python
# 允许改变链表的结构
def is_palindrome(head: ListNode):
	if head is not None:
		slow, fast = head, head
		slow_step = 0
		while fast.next is not None and fast.next.next is not None:
			fast = fast.next.next
			slow = slow.next
			slow_step += 1
		if fast.next is None:
			r_head = reserve_k_nodes(slow, slow_step + 1)
		else:
			r_head = reserve_k_nodes(slow.next, slow_step + 1)
		slow.next = None
		while head is not r_head:
			if head.val != r_head.val:
				return False
			head, r_head = head.next, r_head.next
	return True


# 从起始节点向后k（包含起始节点）个节点
def reserve_k_nodes(node: ListNode, k: int):
	if k <= 1 and node is None:
		return node
	new_tail = node
	pre, post = node, node.next
	for i in range(k - 1):
		post.next, pre, post = pre, post, post.next
	new_tail.next = post
	return pre
```