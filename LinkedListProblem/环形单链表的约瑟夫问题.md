# 环形单链表的约瑟夫问题

> 约瑟夫环就是一个环，给定1个数，每次报数报到这个数的接节点删除，然后下一个继续从1开始，直到剩下最后一个人。要求返回最后剩下的节点

**思路**

单独看约瑟夫问题，在数学上得到答案，然后找到节点是最优解

比如1-2-3-4-5  m = 3

想要直接得出答案，需要依赖前一步的解。动态规划的想法。

比如现在第一步一定是直接删除3号
然后剩下的即使1-2-4-5  m = 3
换个角度看，就是4-5-1-2  m = 3
完全可以看作是4长度时m等于3的解

所以我们可以先写出一些推出来的解

dp[1] = 1
dp[2] = 2
dp[3] = 2
dp[4] = 1

前一个节点的dp[4] =1. 所以说，当前从4这个节点开始看开始看，报1的就是最后的答案！！！
所以就是4

dp[5] = 4   一步可以直接得到结果

现在来分析背后的数学原理

首先设长度为L，然后求出dp[l]即可

当删除第一个节点时，它的下一个节点将会被看作为新的起始节点，问题也变为前一个长度的解，所以首先应该找到给定l和m的情况下要删除的第一个节点的下一个节点是多少

如果

` l>m ------->next = m1 `

如果l<=m的话,那么先找要删除的点
用m%l可以得到值

比如l = 2，m = 3
3 %  2 = 1
所以1就是要删除的点，但是问题在于有可能%运算之后为0，比如l = 2，m = 4
此时意味着其实删除的是2

在数学上可以统一这种情况，就是m先减1，%运算之后在加1即可
((m-1)%l+1)+1

但是可能超出去，所以%l。又有可能等于0，所以先-1，再%，再加1

所以说它的下一个节点就是

`l<=m ------>next = ((m-1) \%l+1)\%l+1`

得到下一个的起始节点之后，再向后+dp[l-1]-1（减1是因为从1开始报数，报到3其实只跑了2步）再%l即可得到解。还是上面的问题，所以先减1，再加1

` result = (next + dp[l - 1] - 1 - 1) \% l + 1`

最后返回dp的最后一个元素即可

**代码**

```python
def solve_joseph_ring(head:ListNode, m:int):
    length = 0
    node = head
    while node is not None:
        length += 1
        node = node.next
    result = get_result_num(length, m)
    node = head
    for i in range(1, result):
        node = node.next
    return node


def get_result_num(length:int, m:int):
    dp = [0, 1]
    for l in range(2, length + 1):
        next_value = get_next(l, m)
        value = (next_value + dp[l - 1] - 1 - 1) % l + 1
        dp.append(value)
    return dp[-1]


def get_next(length:int, m:int):
    if length > m:
        return m + 1
    else:
        delete_value = (m - 1) % length + 1
        next_value = delete_value % length + 1
        return next_value
```

