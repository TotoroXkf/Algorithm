# 反转链表系列问题


- [反转链表系列问题](#反转链表系列问题)
    - [逆序整个链表](#逆序整个链表)
    - [反转指定区间的链表](#反转指定区间的链表)
    - [每K个节点反转一次](#每k个节点反转一次)

下面的所有问题都基于反转链表节点的基础操作。也就是下面的代码

```python
#设置pre和post
pre,post = node.next,node.next.next
# 反转两个节点
post.next, pre, post = pre, post, post.next
# .....全部反转完之后
# 反转之后的尾节点指向后面部分的节点
node.next.next = post
# pre是反转之后的链表的新的头结点，应该由前面的指向它
node.next = pre
```
将pre和post所指的节点反转，然后整体移动两个节点

## 逆序整个链表
> 如题

基于基础操作，每两个节点执行一次即可

```python
def reserve_linked_list(head: ListNode):
    if head is None:
        return None
    pre, post = head, head.next
    while post is not None:
        post.next, pre, post = pre, post, post.next
    head.next = None
    return pre
```

## 反转指定区间的链表
> 给出开始和结束，反转之间的节点。  
> 比如start=3 end=5,表示反转第三个到第五个节点。  
> 1-2-3-4-5-6-7 -----> 1-2-5-4-3-6-7  
> start 和 end 一定是有效的，不会是越界的值

**思路**
--------------------

首先找到指定位置，然后从开始到结束每两个一次操作即可

**代码**
--------------------

```python
def reserve_linked_list_area(head: ListNode, start: int, end: int):
    if head is None:
        return None
    s_head = ListNode(0)
    s_head.next = head
    node = s_head
    for i in range(1, start):
        node = node.next
    if node.next is not None and node.next.next is not None:
        pre, post = node.next, node.next.next
        for i in range(end - start):
            post.next, pre, post = pre, post, post.next
        node.next.next = post
        node.next = pre
    return s_head.next
```



## 每K个节点反转一次
> 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。  
> k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。  
> 示例 :  
> 给定这个链表：1->2->3->4->5  
> 当 k = 2 时，应当返回: 2->1->4->3->5  
> 当 k = 3 时，应当返回: 3->2->1->4->5
> k可能比链表长度大。如果大于链表长度直接返回原链表

**思路**
--------------------

还是基础操作的扩展，就是注意一下拼接的地方就可以了。

**代码**
--------------------

```python
def reverse_k_group(head: ListNode, k: int):
    if k == 0 or k == 1 or head is None:
        return head
    s_head = ListNode(0)
    s_head.next = head
    before, cursor, count = s_head, head, 1
    while cursor is not None:
        if count < k:
            count, cursor = count + 1, cursor.next
        else:
            pre, post = before.next, before.next.next
            for i in range(k - 1):
                post.next, pre, post = pre, post, post.next
            tail = before.next
            before.next.next = post
            before.next = pre
            before, cursor, count = tail, post, 1
    return s_head.next
```