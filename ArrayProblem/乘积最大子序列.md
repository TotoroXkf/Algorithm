# 乘积最大子序列
> 需找最大的连续子序列的乘积和

**思路**

举个例子
[2,-5,-2,-4,3]
那么，从左边开始遍历。第一个元素可以直接跳过
遇到-5
怎么处理这个-5呢？
这样考虑
- 带上2和-5，后面可能再次遇到一个负数，结合成为正数，这个值会比较大
- 不带2，从-5开始从新走。后面可能没有负数了。从-5向后的可能比较大

两种情况都是可能的，所以必须同时记下两种情况的值，然后动态比较出最大来

所以，当前保存两个值，**-5和-10**
在往后，遇到-2
同样的道理
- 带上之前的所有值
- 不带前面两个值，从-2开始从新走。可能会遇到比-5更好的值，结合成为更大的数字

所以现在更新成为 **20和-2**

继续这样
遇到-4
- 带上前面所有的变为-80
- 不带前面值，但是情况稍稍有点变化
	- 如果全部不都不带，那么假设后面遇到一个更好的负数和-4结合，那么前面的就应该全部都要才对。
	- 如果遇不到好的，应该和-2结合向后走才是最合适的
所以当前保存 **8和-80**

再往后就是**-240和24**

中间不断比较max就可以求得最大值

写成算法就是这样的
- 维护max和min
- 分别代表不要前面的部分和要前面的全部
- 所以每次比较nums[i]，max*nums[i]，min*nums[i]三个值，保存最大的，和最小的
- 这样，max和min就分别可能代表上面的情况（有的时候max表示全部的乘起来，也可能反之，取决于负数的个数。min表示剩下的情况）
- 比较出来最大值返回即可


**代码**

```python
def max_product(nums:list):
    if len(nums)==1:
        return nums[0]
    max_value = nums[0]
    min_value = nums[0]
    result = nums[0]
    for i in range(1,len(nums)):
        max_pre = max_value
        max_value = max(max(max_pre*nums[i],nums[i]),min_value*nums[i])
        min_value = min(min(min_value*nums[i],nums[i]),max_pre*nums[i])
        result = max(result,max_value)
    return result
```

