# 全排列问题

- [全排列问题](#全排列问题)
    - [下一个全排列](#下一个全排列)
    - [求第K个全排列](#求第k个全排列)

## 下一个全排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。  
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。  
> 必须原地修改，只允许使用额外常数空间。  
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。  
> 1,2,3 → 1,3,2  
> 3,2,1 → 1,2,3  
> 1,1,5 → 1,5,1

**思路**
--------------------

全排列算法。算是经典算法了

完全倒序是一个排列的最大值，不可能有更大的值。所以从后向前找升序。比如下标[3--last]倒着看是升序的，那就说明从3到最后都是最大的，没办法在改变的。只有找到3前面的这个数字辅助改变  

所以先找那个出现升序的地方。比如1,2,4,3这里，第一对升序出现在2和4这里。4和3是倒序的，不能再排了
然后让i指向2，把j回到最后。找第一个大于i指向的数。然后交换他们两个。

i之后的数字没法排，只能动i这个数字。而顶替i的应该是比i大而又尽可能小的那个数字。原因在于下一个全排列是比当前数大但是又尽可能小的数字。高位值越小越合适。所以顶替的数子顶替i的应该是比i大而又尽可能小的那个数字

这会直接就找到了3这个数。于是变成1,3,4,2

但是还没完。现在i之后的数字还是完全倒叙。下一个全排列的值要尽可能的小，倒序的变为正序的就是最小的。所以反转i后面的部分

比如现在就以干式1,3,2,4,而不是1,3,4,2.而i之后又是完全倒序的。变成正序只要翻转数组就可以

**代码**
--------------------

```python
def next_permutation(nums: list):
    size = len(nums)
    if size == 1:
        return
    i, j = size - 2, size - 1
    while i > -1 and nums[i] >= nums[j]:
        i, j = i - 1, j - 1
    if i != -1:
        j = size - 1
        while j > i + 1 and nums[i] >= nums[j]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
        i += 1
    else:
        i = 0
    j = size - 1
    while i < j:
        nums[i], nums[j] = nums[j], nums[i]
        i, j = i + 1, j - 1
```

## 求第K个全排列
> 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。  
> 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123"  
"132"  
"213"  
"231"  
"312"  
"321"    
给定 n 和 k，返回第 k 个排列。

>示例 1:  
输入: n = 3, k = 3  
输出: "213"  

>示例 2:   
输入: n = 4, k = 9  
输出: "2314"

**思路**
-------------------

康托展开。一个数学办法。
比如n=4，k=3
首先让k--  k=2。

然后存放1到n-1的阶乘----》1 1 2 6
存放每一位数字 1 2 3 4

然后按照计算规则：
用k除以存放阶乘的最后一个 2/6 = 0 。取出并删除存放数字的第0个。也就是1。现在存放的数字变成2 3 4 。字符串拼接1  
然后让k=k%6 k = 2。同理 2/2 = 1 取出第1个 现在是3 拼接字符串变成13。k=k%2 = 0 k =0。0/1 = 0 取出第0个 2 拼接变成132
k = 0%1 = 0。最后一次 k = 0  0/1 = 0 取出4 拼接1324 k = 0%1 = 0

返回1324

**代码**
---------------

```python
def get_permutation(n: int, k: int):
    nums = [1]
    for i in range(1, n):
        nums.append(i * nums[-1])
    number = [i + 1 for i in range(n)]
    k -= 1
    result = ""
    for i in range(len(nums) - 1, -1, -1):
        position = k // nums[i]
        result += str(number.pop(position))
        k = k % nums[i]
    return result
```