# 下一个全排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。  
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。  
> 必须原地修改，只允许使用额外常数空间。  
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。  
> 1,2,3 → 1,3,2  
> 3,2,1 → 1,2,3  
> 1,1,5 → 1,5,1

**思路**

全排列算法。算是经典算法了

完全倒序是一个排列的最大值，不可能有更大的值。所以从后向前找升序。比如下标[3--last]倒着看是升序的，那就说明从3到最后都是最大的，没办法在改变的。只有找到3前面的这个数字辅助改变  

所以先找那个出现升序的地方。比如1,2,4,3这里，第一对升序出现在2和4这里。4和3是倒序的，不能再排了
然后让i指向2，把j回到最后。找第一个大于i指向的数。然后交换他们两个。

i之后的数字没法排，只能动i这个数字。而顶替i的应该是比i大而又尽可能小的那个数字。原因在于下一个全排列是比当前数大但是又尽可能小的数字。高位值越小越合适。所以顶替的数子顶替i的应该是比i大而又尽可能小的那个数字

这会直接就找到了3这个数。于是变成1,3,4,2

但是还没完。现在i之后的数字还是完全倒叙。下一个全排列的值要尽可能的小，倒序的变为正序的就是最小的。所以反转i后面的部分

比如现在就以干式1,3,2,4,而不是1,3,4,2.而i之后又是完全倒序的。变成正序只要翻转数组就可以

**代码**

```python
def next_permutation(nums: list):
    size = len(nums)
    if size == 1:
        return
    i, j = size - 2, size - 1
    while i > -1 and nums[i] >= nums[j]:
        i, j = i - 1, j - 1
    if i != -1:
        j = size - 1
        while j > i + 1 and nums[i] >= nums[j]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
        i += 1
    else:
        i = 0
    j = size - 1
    while i < j:
        nums[i], nums[j] = nums[j], nums[i]
        i, j = i + 1, j - 1
```