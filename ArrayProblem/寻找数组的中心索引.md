# 寻找数组的中心索引
> 中心索引：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和  
> 对于最左侧的值，它的左边的累加和为0.最右侧的右边累加和为0  
> 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个  
> 输入:   
nums = [1, 7, 3, 6, 5, 6]  
输出: 3  
解释:   
索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。  
同时, 3 也是第一个符合要求的中心索引。  

**思路**
--------------------

这个题是很经典的数组预处理思路的题。

暴力法就是遍历到每一个位置都求一次左边的累加和和右边的累加和。所以需要预处理数组，将左右两边的和记下来。

- 首先记下来从左往右的累加和。记为letf_sum。这个值直接迭代求和即可
- 从右向左遍历数组。left_sum减去num[i]的值就相当于这个位置左边的累加和了。这好理解。同时维护右边的累加和right_sum。如果这两个值相同说明是中心索引，记录位置
- 从右向左每一次出现的中心索引都应该更新最后的位置，因为要求最左边的。

最后返回记录的位置即可

**代码**
--------------------

```python
def pivot_index(self, nums: list):
    size = len(nums)
    if size == 0:
        return -1
    position, left_sum, right_sum = -1, sum(nums), 0
    for i in range(size - 1, -1, -1):
        left_sum -= nums[i]
        if left_sum == right_sum:
            position = i
        right_sum += nums[i]
    return position
```