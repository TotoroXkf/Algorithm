### 找到数组中累加小于等于目标值的最长子数组
> 如题

**思路**

和上面的题相似的思路
有数组

`
[a,b,c,d,e,f,g]
`

假设遍历到f
其中存在，以f结尾的子数组的某个子数组是加起来小于等于target的
如何得到这个子数组呢？
假设要得到def

`
sum = a+b+c+d+e+f
`

`
d+e+f = sum - a-b-c
`

所以可以没遍历到一个位置，就记录到这个位置的sum值
但是我如何知道def是符合条件的呢？？
和上面的题一样，需要额外的辅助数组
这个辅助数组记录的是当前位置的累加出现的最大值。并且额外加入一个0作为第一个元素
意思就是到这个位置的累加最大值
之所以要这样作，是为了满足下面的推导
假设

`
d+e+f \leq target
`

`
d+e+f = sum - x
`

`
sum - x \leq target
`

`
x \geq sum-target
`

也就是说，当迭代到一个位置，加出来了sum，用它减去target，只要能找到从这个位置向前的，第一个累加值大于sum-target的值的位置下标，就可以得到想要的长度
所以辅助数组保存的是到当前位置的最大的累加值
比如

`
[1,2,-1,5,-2]
`

第一个元素额外添加，为0
累加sum为

`
[0,1,3,2,7,5]
`

变为

`
[0,1,3,3,7,7]
`

这样变换的意义在于假设减去一个值小于target，减去更大的值也小于target，而且有可能向前延伸
比如不变换时候的2，假设减去2可以小于等于target，那么减去前面的3还是可以小于等于target，这是一定的。而从3的位置又变长了一个长度
这就是辅助数组存在的意义
由于辅助数组是递增的，所以可以快速定位到sum-target的位置。使用二分查找。
只要找到第一个大于等于sum-target的值即可

**代码**

```kotlin
fun getMaxLength(array: IntArray, target: Int): Int {
    val helpArray = IntArray(array.size + 1)
    var sum = 0
    helpArray[0] = 0
    for (index in 1 until array.size) {
        sum += array[index]
        helpArray[index] = max(helpArray[index - 1], sum)
    }
    sum = 0
    var result = 0
    for (index in array.indices) {
        sum += array[index]
        val position = getLessIndex(helpArray, sum - target, index + 1)
        if (position != Int.MIN_VALUE) {
            result = max(result, index - position + 1)
        }
    }
    return result
}

fun getLessIndex(array: IntArray, target: Int, end: Int): Int {
    if (target <= 0) {
        return 0
    }
    if (target > array[end]) {
        return Int.MIN_VALUE
    }
    var left = 0
    var right = end
    var mid: Int
    var result = Int.MIN_VALUE
    while (left <= right) {
        mid = (left + right) / 2
        if (array[mid] >= target) {
            result = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return result
}
```

