# 生成窗口最大值数组

> 给定一个数组和窗口大小，窗口不断向右移动，求出所有窗口内的最大值
[4  3  5]  4  3  3  6  7 ----->当前窗口最大值为5
最终结果为[5,5,5,4,6,7]

**思路**

维护一个下一个有效比较的队列，通过这个队列来得到每一步的最大值

比如例子中的4,3,5,4,3,3,6,7这个数组

刚开始遇到4，将4的下标入队，队列为{0}
然后遇到3,用3和队头比较（因为队头代表了当前窗口的最大值），3比4小，说明当前窗口的最大值依旧是4，也就是队列头。但是这个数随着窗口的滑动可能会过期，所以，即使这个3比4小，但是它完全可能时之后的窗口内最大值，入队，队列为{0,1}

紧接着遇到5，5大于4，说明最大值将会变动为5，所以将4出队，继续比较，3还是比5小，再出队，然后5的下标入队，队列为{2}

此时可以专门计数一下，从0-2的窗口的最大值已经得到，就是队头，也就是5

再然后的过程都一样，遇到4，和5比较，依旧是5最大，然后把4入队，作为之后的有效比较对象。队列变为{2,3}。

注意，从这里开始每一次循环都应该记录一个结果，表示窗口内最大值，就是队头

记录结果 5

同理，变为{2,3,4}  记录结果 5

继续，遇到3，此时跨度超过window_size，将5出队，4成为当前区域最大值，和3比较。3小，将3的小标入队。队列变为{3,4,5} ,记录结果 下标为3的元素，4

继续，遇到6，全部出队，6入队，记录6

同理，记录7

最终结果[5,5,5,4,6,7]

时间复杂度 O(n)

**代码**

```python
def get_window_max_values(nums, k):
    """
    :type nums:list
    :type k:int
    :rtype:list
    """
    if k > len(nums):
        return None
    result = []
    max_queue = []
    index = 0
    length = 0

    while index < len(nums):
        if len(max_queue) == 0:
            max_queue.append(index)
        else:
            if index - max_queue[0] == k:
                max_queue.pop(0)
            while max_queue and nums[max_queue[-1]] < nums[index]:
                max_queue.pop(-1)
            max_queue.append(index)
        length += 1
        if length >= k:
            result.append(nums[max_queue[0]])
        index += 1
    return result
```



