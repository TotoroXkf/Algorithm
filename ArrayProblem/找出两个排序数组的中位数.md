# 两个排序数组的中位数
> 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。  
请找出这两个有序数组的中位数。

**思路**

这道题的最优解的复杂度是O(log(min(m,n)))

这道题是数学上的胜利

A和B都是排好序的。我们假设他们合并的数组叫做C，也是有序的

那么要求C的中位数，就是从A中找到一些数，B中找到一些数，他们组成了C的左半部分。所以假设A中有i个数字在C的左半部分，B中有j个数字在左半部分而i+j是C的一半.
 
`A=[ i | m-i ]`  
`B=[ j | n-j ]`  
`C=[ i+j | (m+n)/2 ]`  

接下来这步很关键  
理论上来说，i+j应该等与(m+n)/2的。因为正好一半。但是这样的话，m+n为奇数的话，比如为7，左边3个，右边3个，中间这个数字，放在哪里呢？其实放在左边更加合适，后面就知道了。所以应该是(m+n+1)/2。这样的话就一定划到左半部分。（7+1）2=4.如果m+n是偶数，+1再除2不影响什么

第一个条件:
`i+j = (m+n+1)/2 -> j = (m+n+1)/2-i`

注意，i从0到m，如果m大于n的话，j有可能是负数，所以还是让m<=n.这也好办，让两个数组比较长度，交换一下就可以了

按照上面的分析，i表示A中的i个数字。那么A[0]-A[i-1]都是C中的左半段的数字了。同理，B[0]-B[j-1]都是左半段的数字

那么，A[i-1]是A中最后在C中左半段的最大值，B[i-1]是B中最后在C中左半段的最大值。进一步推导  

**A[i-1]和B[j-1]一定有一个是C中左半段的最大值**

A[i]一定大于A[i-1],如果能同时大于B[j-1]，那么就说明A[i]在C中的右半段。同理，B[j]大于B[j-1],如果能大于A[i-1],那么B[j]就一定在C中的右半段。而A[i]和B[j]又是离A[i-1]和B[j-1]最近的两个值，所以

**A[i-1]和B[j-1]一定有一个是C中右半段的开始的值，也就是最小值**

再进一步可以想到，A[i-1]和B[j-1]谁大谁就在C中靠右。所以大的是C中左半段的最大值。而A[i]和B[j]谁小谁就靠左，小的是C中右半段的最小值

`C[......max(A[i-1],B[j-1])],min(A[i]和B[j])......`

结果是显而易见的，如果m+n是奇数，那么max(A[i-1],B[j-1])]就是中位数。因为它是中间的那个数（前面说过了，划分给左半段）。如果m+n是偶数，(max(A[i-1],B[j-1])],min(A[i]和B[j]))/2 就是答案了，左半段的最大值和右半段的最小值的中间数字

所以说，第二个条件是:
`A[i]>=B[j-1] and A[i-1]<=B[j]`

这两个条件能同时满足就可以秋的中位数了

所以，机体的操作就是
- 让i在m中移动（二分查找）
- 计算出j。j=(m+n+1)/2-i
- 判断A[i]>=B[j-1] and A[i-1]<=B[j]条件
    - i>0 and A[i-1]>B[j]
        - 说明A[i-1]太大了.那么i就向左移动。抛弃右半区间
    - i<m and A[i]<B[j-1]
        - 说明A[i]太小了，向右移动，抛弃左半区间
    - 否则，说明i在正确的位置上
        - 判断情况，得出答案
            - 判断max(A[i-1],B[j-1])]，得出左边最大值。有可能是i=0或者j=0。这说明A整个就在B的右边。就没有A[i-1]了，直接就是B[j-1]。j=0同理
            - 判断min(A[i]和B[j])，得出右边最大值。i=m和j=m的道理同上。没有就不比较，剩下谁就是谁
            - m+n是奇数，返回左边最大值
            - m+n是偶数，返回(左边最大值+右边最大值)/2

数学的胜利。。。。

**代码**

```python
def find_median_sorted_arrays(nums1: list, nums2: list):
    if len(nums1) > len(nums2):
        nums2, nums1 = nums1, nums2
    m, n = len(nums1), len(nums2)
    left, right, half_len = 0, m, (m + n + 1) // 2
    while True:
        i = (left + right) // 2
        j = half_len - i
        if i > 0 and nums1[i - 1] > nums2[j]:
            right = i - 1
        elif i < m and nums1[i] < nums2[j - 1]:
            left = i + 1
        else:
            if i == 0:
                max_left = nums2[j - 1]
            elif j == 0:
                max_left = nums1[i - 1]
            else:
                max_left = max(nums1[i - 1], nums2[j - 1])

            if (m + n) % 2 == 1:
                return max_left

            if i == m:
                max_right = nums2[j]
            elif j == n:
                max_right = nums1[i]
            else:
                max_right = min(nums1[i], nums2[j])

            return (max_right + max_left) / 2
```