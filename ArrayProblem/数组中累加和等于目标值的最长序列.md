# 数组中累加和等于目标值的最长序列
> 给定数组和target，求出相加等于目标值的最长的子数组的长度。数组包含正数，负数，0

**思路**
--------------------

很经典的问题  
还是先抽象问题  
有数组  

`
[a,b,c,d,e,f,g]
`

假设c，d加起来等于target，就是最后解，长度为2  
那么，如何得知c+d的值呢？  
可以这样  

`
a+b+c+d - (a+b) = c + d =target
`

所以说可以记录每一个位置的和，记录下来所在的位置。可以使用map来保存  
然后用当前的sum值，减去target，看看有没有保存这个值，有的话就可以得到长度了。  

`
sum = a+b+c+d
`

`
sum - target = c + d
`

所以步骤就是
- 每走到一个位置，记下来从最开始到当前位置的值
- sum - target，看看map存在不存在这个值
- 存在的话，取出对应的value，当前位置减去value得到长度
- 保存当前的值和位置到map

这里有个小细节  
假设

`
a+b+c+d = a+b+c+d+e+f
`

那么a这个值应该存在a+b+c+d所在的位置3还是a+b+c+d+e+f的位置5？  
明显存在3更加合适  
如果后面有值需要减去这个值的话，减去3会比减去5得到更长的长度  
所以map保存的位置都应该是第一次出现的位置  

另外，可以保存（0，-1），让代码统一起来，而不用额外做很多判断  

**代码**
--------------------

```python
def get_max_length(array: int, target: int):
    position_map = {}
    position_map[0] = -1
    max_len = 0
    count = 0
    for i in range(0, len(array)):
        count += array[i]
        key = count - target
        if position_map.__contains__(key):
            start = position_map[key]
            max_len = max(i-start, max_len)
        if not position_map.__contains__(count):
            position_map[count] = i
    return max_len
```