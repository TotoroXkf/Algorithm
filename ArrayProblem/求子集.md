# 求子集

## 不包含重复元素
> 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  
> 输入: nums = [1,2,3]。 
输出:  
[  
  [3],  
  [1],  
  [2],  
  [1,2,3],  
  [1,3],  
  [2,3],  
  [1,2],  
  []  
]  

**思路**
-------

比较典型的dfs问题了。这种题做的多了也就都是一个套路了

由于不包含重复元素，所以直接的方式求解即可。
每遍历到一个元素，创建一个新的子集，加入结果，然后位置向前移动1，递归求解即可

**代码**
-------

```python
def subsets(nums):
	result = [[]]
	ans = []
	dfs(nums, 0, ans, result)
	return result


def dfs(nums: list, i: int, ans: list, result: list):
	if i >= len(nums):
		return
	for j in range(i, len(nums)):
		temp = ans + [nums[j]]
		result.append(temp)
		dfs(nums, j + 1, temp, result)
```

## 包含重复元素 
> 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 
> 输入: [1,2,2]   
输出:  
[  
  [2],  
  [1],  
  [1,2,2],  
  [2,2],  
  [1,2],  
  []  
]  

**思路**
-------

一般来说这种dfs的包含重复元素的题就是先排序，然后在处理的时候主动规避重复解。 
先排序，会重复的情况是当前位置不是传递下来的位置，而且与前一个元素相同。这样的解主动规避即可。  
道理是这样，当这个元素是传下来的第一个元素就不管它是不是和前面值重复了，因为后面的重复值规避保证了这个过程。但是当这个位置不是传递下来的位置，说明向后移动了，那么如果和前一个元素相同就说明一定会产生重复的值。所以判断这个条件规避即可


**代码**
-------

```python
def subsets(nums):
	nums.sort()
	result = [[]]
	ans = []
	dfs(nums, 0, ans, result)
	return result


def dfs(nums: list, i: int, ans: list, result: list):
	if i >= len(nums):
		return
	for j in range(i, len(nums)):
		if j > i and nums[j - 1] == nums[j]:
			continue
		temp = ans + [nums[j]]
		result.append(temp)
		dfs(nums, j + 1, temp, result)
```

