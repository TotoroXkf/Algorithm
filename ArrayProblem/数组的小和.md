# 数组的小和
>数组小和的定义如下：  
>例如，数组s=[1，3，5，2，4，6]  
在s[0]的左边小于或等于s[0]的数的和为0  
在s[1]的左边小于或等于s[1]的数的和为1  
在s[2]的左边小于或等于s[2]的数的和为1+3=4  
在s[3]的左边小于或等于s[3]的数的和为1  
在s[4]的左边小于或等于s[4]的数的和为1+3+2=6  
在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15  
所以s的小和为0+1+4+1+6+15=27。  
给定一个数组s，实现函数返回s的小和。

**思路**

比较难想到办法的一个题  
最优解是归并思路的办法（也不知道是怎么想到的。。。。）  

`
[a,b,c,d,e,f]
`

我们假设a，b，c有序，d，e，f有序  
但是整体无序  
然后按照归并排序的做法  
比较a和d  
如果  

`
d >= a
`

必然有  

`
f >= e >= d  >= a
`

所以，对于元素d，e，f来说，在计算小和的时候也是要加a的  
所以此时直接加上  

`
sum+=a*len(d.....f)
`
 
那如果反过来，a>d，说明d的小和不加a，后面的不知道，往后走的时候自然直到  
所以，a>d，不处理结果，继续归并即可  
不论是左半数组遍历结束还是右半数组遍历结束，说明整体的小和都加完了，剩下的直接放入数组即可  
如此归并下去，每一次合并都是在榨出当前这个区间的小和，最后整体的也会榨出来  
这个题使用归并的精妙之处在于左半数组和右半数组保持了相对的位置  
可能abc的位置在归并的时候发生了变化，但是到这一步，a和d的相对位置并没有发生改变， a还是在d的前面，a，b，c的位置无关紧要了  
而abc的位置在归并abc的时候又保持了相对位置，重复了这个过程  
真的精彩！  



**代码**

```python
def get_small_sum(array: list, left=-1, right=-1):
    if left == -1 and right == -1:
        if len(array) == 0:
            return 0
        return get_small_sum(array, 0, len(array) - 1)

    if left == right:
        return 0
    mid = (left + right) // 2
    left_result = get_small_sum(array, left, mid)
    right_result = get_small_sum(array, mid + 1, right)
    result = merge(array, left, mid, right)
    return result + left_result + right_result


def merge(array: list, left: int, mid: int, right: int):
    if left == right:
        return 0
    temp = []
    i = left
    j = mid + 1
    count = 0
    while i <= mid or j <= right:
        if i > mid or (j <= right and array[i] > array[j]):
            temp.append(array[j])
            j += 1
        else:
            if i <= mid and j <= right:
                count += ((right - j + 1) * array[i])
            temp.append(array[i])
            i += 1
    index = left
    for value in temp:
        array[index] = value
        index += 1
    return count
```

