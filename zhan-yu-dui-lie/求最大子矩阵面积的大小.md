### 求最大子矩阵面积的大小
> 给出一个只有0和1的举证
1 0 1 0
1 1 1 0
1 1 1 1
连续1的最大面积为6

**思路**

从矩阵的最底下一行向上面看的话，等于一些高度的条状，然后求最大能围成的面积
就举出的例子来看的话，相当于是[3,2,3,1]的4条长度的条状，问能围成的面积
所以这个问题是一维数组能围成的面积

首先考虑比较简单的情况。如果全部都是升序的是个什么情况？比如1,3,4,7,11
那么，可能情况就是1*5||3*4||4*3||7*2||11*1，其中有一个最大值

然后考虑在升序当中出现乱序的情况，比如2,3,1
这时的最大值可以这样想。抛开1不管，只看2和3是有序的，是可以必出2和3组成的最大值。然后1加入，1比2和3都小
那么就会多出一种情况就是带着1跨过整个数组，1*3的情况
比较上面的的值可以求出最大值

再然后考虑更复杂的情况，1后面假设还有值2,3,1,2,3
先看1左边的2和3，得出各种情况。
然后遇到1，但是这时不应该处理1，因为1后面还有数字，不知道是带着1向后还是1就在这里处理
所以不处理。但是这时的2和3已经处理过了。所以完全可以大胆的把2和3都看作1！
因为2和3想要向后扩展必须跨过1，那就只能视作为1.而不跨过1的情况已经处理过了。所以大胆看作1
变成1,1,1,2,3 这时再次得到升序的数组，求解即可

再来看更加特殊的情况 1,3,4,2,6,5。这基本可以当做一般情况了
首先1,3,4有序，遇到2，这时，2大于1，也就是说没有办法让2没过1，所以即使1,3,4,有序，但是也只能处理3和4
然后变成1,2,2,2,6,5。6和5还不是有序的。但是流程和之前的是一样的。1,2,2,2,6是有序的，遇到5......

综上所述。这个题的关键就是要不断地创建一个升序的数组。在构建的途中处理不是升序的部分，求得最优解
这里提供一个完整的分析，配合下面的代码分析清楚这个题
比如4,2,0,3,2,5这个例子
首先遇到4，没问题，把4的下标(必须是下标)进栈。然后遇到2，和栈顶比较，比4小，入栈会成为无序，所以把4出栈
然后这时的i在1位置，出栈的元素代表的位置是0。此时栈为空，长就是4，宽就是4*i
想想看，栈空了，表示遇到的元素小于栈里面所有的元素。比如2,6,9,1这种。遇到1，6和9都出栈了，2的处理就因该是2*3
所以此时，就是4去乘上i所在的位置表示area
然后理论上这个数组因该就变成2,2,0,3,2,5了。但是在写法上不用这样。直接把2所在的下标，也就是1入栈就好了
这也是间接的表示1下标之前的数字都是2
随后遇到0把2的下标1出栈,然后栈空，area是2*i(i此时是2);
再遇到3，入栈，遇到2，把3弹出，这时栈不为空，还有个0的下标在里面。此时area应该是i-2(栈顶元素，也就是0的下标)-1
这里注意，一定是减去栈顶的下标。为什么之后说
然后2入栈，遇到5，入栈。遍历结束。这时要在处理一次栈。也就是在数组末尾假装还有一个0.这样按照上面的分析就能把栈里面的元素都给处理了
现在遇到自己加入的0，此时的栈为2(0的下标),4(后面那个2的下标),5(5的下标)。
5出栈，5*(6-4-1) = 5*1 = 5
4出栈，2*(6-2-1) = 2*3 = 6   (这个例子中的最大值)
2出栈，0*6 = 0;
结束

现在说说为什么是减去栈顶元素
按照上面的分析，最后一次数组应该已经成为0,0,0,2,2,5
在弹出5的时候，5只有自己一个值，那么就算是不这么算也是可以的。比如用i减去弹出的栈顶元素也可以算出宽度来
但是弹出4的时候就不是了。3位置也是个2，也因该一并考虑进去的，此时如果还是用i减去弹出的栈顶元素，那么就算了2*2，漏掉了3位置的2，

**代码**

```java
fun maximalRectangle(matrix: Array<CharArray>): Int {
    if (matrix.isEmpty() || matrix[0].isEmpty()) {
        return 0
    }
    val height = IntArray(matrix[0].size)
    var max = 0
    for (i in matrix.indices) {
        for (j in 0 until matrix[0].size) {
            if (matrix[i][j] == '1') {
                height[j] += 1
            } else {
                height[j] = 0
            }
        }
        max = Math.max(max, largestRectangleArea(height))
    }
    return max
}

private fun largestRectangleArea(heights: IntArray): Int {
    var maxArea = 0
    val stack = Stack<Int>()
    for (i in 0 until heights.size + 1) {
        var height = 0
        if (i < heights.size) {
            height = heights[i]
        }
        while (!stack.isEmpty() && heights[stack.peek()] > height) {
            val position = stack.pop()
            val area: Int
            if (stack.isEmpty()) {
                area = heights[position] * i
            } else {
                area = (i - stack.peek() - 1) * heights[position]
            }
            if (area > maxArea) {
                maxArea = area
            }
        }
        stack.push(i)
    }
    return maxArea
}
```


