# 目标和
>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。  
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。  
>输入: nums: [1, 1, 1, 1, 1], S: 3  
输出: 5  
解释:   
-1+1+1+1+1 = 3  
+1-1+1+1+1 = 3  
+1+1-1+1+1 = 3  
+1+1+1-1+1 = 3  
+1+1+1+1-1 = 3  
一共有5种方法让最终目标和为3。  

**思路**
--------------------

非常赞的一道二维动态规划问题

假设数组有[x,y,z,a,b].由于只能有正号和负号。所以一定是一些正的数字加上一些负的数字得到target。我们假设xyz都是正的，ab的符号是负的。

`sum(x,y,z) - sum(a,b) = target`  
`sum(x,y,z) + sum(a,b) = sum(nums)`  
`2*sum(x,y,z) = target+sum(nums)`  
`sum(x,y,z) = (target+sum(nums))/2`

上面的推导十分关键！  
target和sum(nums)都是固定值。

**这就是说，我们的目标变成了在这个给定的数组中找到子集和等于(target+sum(nums))/2**

每一个子集都对应着一个答案。这些满足条件的子集的个数就是最后的答案！

并且给定的数组是正数，所以子集和一定是正整数。所以如果(target+sum(nums))/2等于分数的话就不存在满足条件的子集。返回0.

那么怎么找这些子集？？？

使用二维的dp数组即可。

`dp[i][j]`表示前i个数字能组成j的方法数总和

`dp[i][0] = 1 不用热河子集就可以组成0.只有一种方法`

dp[i][j]的来源
- 不使用当前的nums[i]，能组成的方法数。就是dp[i-1][j]
- 使用当前的nums[i]，使用这个数之前的方法数。就是dp[i-1][j-nums[i]]

`dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]`

最后一个元素就是答案

还可以进一步压缩这个二维的dp数组。因为只依赖上方的解和左上方的解。所以一维的也可以胜任

`dp[i] = dp[i] + dp[k-nums[i]]`

果然数学才是王道

**代码**
--------------------

```python
def find_target_sum_ways(nums: list, target: int):
    count = sum(nums)
    if count < target or (target + count) % 2 == 1:
        return 0
    t = (target + count) // 2
    dp = [0] * (t + 1)
    dp[0] = 1
    for n in nums:
        for k in range(t, n - 1, -1):
            dp[k] += dp[k - n]
    return dp[t]
```