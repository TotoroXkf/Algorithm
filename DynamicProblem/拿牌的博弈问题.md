### 拿牌的博弈问题
> 给出一个数组当作一组牌，排列成一行，每一次只能拿走最左边的或者最右边的牌。假设两个人都很聪明，每步拿的都是当前能拿到的最好的牌，求胜利者最后的总数
> 比如  [1,2,100,4]
> A先拿1，B拿4，A拿100，B拿2
> A胜出，返回101

**思路**

这个题的关键是怎么知道每一步拿哪张牌是最好的
假设数组

`
[a,b,c,d,e]
`

首先是A拿牌，可能拿a，也可能拿e

随后是B拿牌。按照A拿完的结果，B可能在[a...d]里面拿牌，也可能在[b...e]里面拿牌。

这一步分析是关键

**A的最好结果应该是拿了a之后B在[b...e]里面拿牌的最终解和拿了e之后B在[a...d]里面拿牌的最终解的最大值**

将B在[b...e]里面拿牌的解看作为一个递归的过程

所以定义一个操作f(i,j)和一个操作s(i,j)

f表示先拿牌的操作。f(i,j)表示从i到j区间可能拿到的最大值

s表示后拿牌的操作。s(i,j)表示从i到j区间可能拿到的最大值


如果区间长度只有1

`
f(i,i) = num[i]
`

`
s(i,i) = 0
`

如果超过1

按照上面的分析，先拿的要看后拿的最后解来确定

`
f(i,j) = max(num[i]+s(i+1,j),num[j]+s(i,j-1)) 
`

后手拿的解等于什么呢？

如果给出一个区间，后手拿等于对方先拿一个，然后在剩下的区间里面先手拿

后手可能遇到的区间是两个，二题目假设每一次都拿的是当前的最好解，所以先手一定是给后手剩下了一个不好的区间，也就是后手成为先手时小的那个区间

`
s(i,j) = min(f(i+1,j),f(i,j-1))
`

到这里就分析完了。可以暴力递归求解，但是还可以优化成为动态规划解

f和s保存成为矩阵，避免反复运算

比如  [1,2,100,4]

最后生成的f矩阵就是

| ..... | 0     | 1     | 2     | 3     |
| :---: | :---: | :---: | :---: | :---: |
| 0     | 1     | 2     | 101   | 101   |
| 1     |       | 2     | 100   | 6     |
| 2     |       |       | 100   | 100   |
| 3     |       |       |       | 4     |

最后生成的s矩阵
| ..... | 0     | 1     | 2     | 3     |
| :---: | :---: | :---: | :---: | :---: |
| 0     | 0     | 1     | 2     | 6     |
| 1     |       | 0     | 2     | 100   |
| 2     |       |       | 0     | 4     |
| 3     |       |       |       | 0     |

从右下角开始遍历
最后回到右上角，得到解

**代码**

```python
def game(nums: list):
    f = []
    s = []
    for i in range(len(nums)):
        f_line = [0 for j in range(len(nums))]
        s_line = [0 for j in range(len(nums))]
        f.append(f_line)
        s.append(s_line)
    for i in range(len(nums) - 1, -1, -1):
        f[i][i] = nums[i]
        for j in range(i + 1, len(nums)):
            f[i][j] = max(nums[i] + s[i + 1][j], nums[j] + s[i][j - 1])
            s[i][j] = min(f[i + 1][j], f[i][j - 1])
    return max(f[0][-1], s[0][-1])
```