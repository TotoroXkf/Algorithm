# 最长上升子序列

>给定一个无序的整数数组，找到其中最长上升子序列的长度。
>输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

**思路**

先分析n^2的解法，然后过渡到nlogn的解法  
10, 9, 2, 5, 3, 7, 101, 18按照这个例子来分析  
首先构建dp数组。dp(1)=1  
dp(2) = 1.因为10大于9  
dp(3) = 1.同理。9和10大于2  
dp(4) = dp(3)+1.因为2小于5，所以5对应的dp数组因该是这样  
dp(5) = dp(3)+1.同上  
dp(6)=max{dp(3),dp(4),dp(5)}+1 .2,5,3都小于7，所以写出状态转移方程，求得最大的dp  

后面都一样。最后找到dp数组中的最大值就是这个问题的解。代码不难写。遍历到一个数就查找它之前的比他小的数对应到dp数组的值.然后求一个最大加一就是自己的。找出最大的dp值就可以了

现在分析nlong的解法

上述方法的问题在于重复找了很多无用的值，导致效率低下  
仔细观察这个数组。在遇到2的时候其实10和9就已经失去比较的价值了。  
9和10和2的dp值都是1.所以即使后面有数字，只需要与2比较就能确定能不能加1了。比9或者10大的一定比2大。  
同样的，把这个思路推广。所有同dp值的位置中，后来数字只需要和其中最小的数字比较就可以了。  
基于这个思路在写法上就可以写出跟简单高效的算法

还是这个例子。这次dp数组不按照之前的法则构造  

首先遇到10.  
dp(1) = 10  

然后遇到9.  
9比dp数组中所有值都小。所以直接可以确定他就是原来dp数组中那个dp为1的值。并且它还比10小。按照前面的分析9应该顶替10。10失去效应。所以dp(1)变为9  
同理遇到2，dp(1)变为2

然后遇到5.
5大于2，这就说明2和5可以组成升序的序列。所以5理应为原dp值为2的元素。所以现在构建的dp(2) = 5

然后遇到3.按照之前的分析，3大于2，应该让5失效。所以dp(2) = 3

同理向后。最后dp数组为2 3 7 18

这时的dp数组的长度就是最后的答案。不过要注意一点的就是dp数组的值并不是那个最好的升序数组。这个题是碰巧了

再仔细想想看这里的dp数组，应该能理解，dp数组代表了之前的个dp数组同一dp值的最小数字2是dp为1的最小数字，3是dp为2的最小数字，7是dp为3的......

这个dp数组的构建很简单，因为他总是保持着升序，所以新元素的处理直接二分查找，看看是入队还是替换之前的元素

所以此时的复杂度是nlogn

**代码**

```kotlin
fun lengthOfLIS(nums: IntArray): Int {
    val list = ArrayList<Int>()
    for (i in nums.indices) {
        if (list.isEmpty()) {
            list.add(nums[i])
        }
        handleElement(list, nums[i])
    }
    return list.size
}

private fun handleElement(list: MutableList<Int>, value: Int) {
    var left = 0
    var right = list.size - 1
    while (right - left > 1) {
        val mid = (left + right) / 2
        when {
            list[mid] == value -> return
            value > list[mid] -> left = mid
            else -> right = mid
        }
    }
    when {
        value <= list[left] -> list[left] = value
        value > list[right] -> list.add(value)
        else -> list[right] = value
    }
}
```