# 打家劫舍系列问题

- [打家劫舍系列问题](#打家劫舍系列问题)
    - [题型1](#题型1)
    - [题型2](#题型2)

## 题型1

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

>输入: [1,2,3,1]  
输出: 4  
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  
     偷窃到的最高金额 = 1 + 3 = 4 。
     
>输入: [2,7,9,3,1]  
输出: 12  
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。  
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


**思路**

很基础的动态规划问题

`
dp[0] = nums[0]
`

`
dp[1] = max(nums[0],nums[1])
`

第i个值分两个情况
- 要这个值，和dp[i-2]结合
- 不要这个值，当前值等于dp[i-1]
比较出max来

所以

`
dp[i] = max(dp[i-1],nums[i]+dp[i-2])
`

最后一个元素就是答案

**代码**

```python
def rob(nums:list):
    size = len(nums)
    if size==0:
        return 0
    if size ==1:
        return nums[0]
    pre = nums[0]
    last = max(nums[0],nums[1])
    for i in range(2,size):
        temp = last
        last = max(last,nums[i]+pre)
        pre = temp
    return last
```

## 题型2

>和1的情况差不多，但是首尾是相通的。选了最后一个就不能选第一个了

**思路**

举个例子  
[a,b,c,d,e]  
如果包含a有哪些可能的解呢？  
只可能是  
- [a,c]
- [a,d]  
  
包含a的解一定包含在从0到length-2的dp解（见1）

再看不包含a的解
- [b,d]
- [b,e]
- [c,e]
  
同理，是从1到length-1的dp的解

两次dp求解即可

**代码**

```python
def rob2(nums: list):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    return max(rob(nums, 0, size - 1), rob(nums, 1, size))


def rob(nums: list, start: int, end: int):
    pre = nums[start]
    last = max(nums[start], nums[start + 1])
    for i in range(start+2, end):
        pre, last = last, max(last, nums[i] + pre)
    return last
```