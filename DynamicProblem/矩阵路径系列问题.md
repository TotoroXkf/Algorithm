# 矩阵路径系列问题

## 题型1
> 给出矩阵的长和宽，刚开始位于左上角。每次只能往下或者往右。计算走到右下角有多少种走法


**思路**
--------------------

这个题可以用数学手段O(n)解出来。至于为什么。。。（又不是不能用）

```python
# 公式C^(m-1)_(m+n-2)  就是在(m+n-2)中取(m-1)个的数量

def unique_paths(m: int, n: int):
    res = 1
    for i in range(m, m+n-1):
        res *= i
        res /= i-m+1
    return int(res)
```

再说一般的dp解法。时间复杂度为O(n^2)。dp[i][j]表示到(i,j)位置一共有多少种走法。

当走到(i,j)位置，所有的可能分别是
- 从上方来的dp[i-1][j]
- 从左边走过来的dp[i][j-1]

最后是他们加起来

`dp[i][j] = dp[i-1][j]+dp[i][j-1]`

由于之和左侧和上方的值有关，所以可以压缩矩阵空间变为一维数组。一维数组是行和列短的那个

`dp[i] = dp[i] + dp[i-1]`

**代码**
--------------------
```python
def unique_paths(self, m: int, n: int):
    row_more = True if n > m else False
    dp = [0] * (min(m, n))
    dp[0] = 1
    for i in range(n if row_more else m):
        for j in range(1, m if row_more else n):
            dp[j] = dp[j - 1] + dp[j]
    return dp[-1]
```

## 题型2
> 给出矩阵，每次只能往下或者往右。矩阵的值意味着走到这里的花费。计算出最小的花费

**思路**
--------------------
二维dp问题 
就是计算出左边走过来值更大还是上面走过来更大  

`dp[0][0] = matrix[0][0] `


`dp[i][j] = min(dp[i][j-1],dp[i-1][j])`


进一步优化可以压缩这个二维的dp数组  
可以选择按照行还是按照列遍历  
因为dp值只和前面左边的和上面的有关  
所以dp可以转换为1维的，不断比较之前的值就可以  
dp[i-1]和dp[i]跟分别表示了左面的值和上面的值（也可能反过来，看是按照行遍历还是列遍历）  

`dp[i] = min(dp[i-1],dp[i])+matrix[i][j]/matrix[j][i]`


**代码**
--------------------

```python
def min_path_sum(matrix: list):
    more = max(len(matrix), len(matrix[0]))
    less = min(len(matrix), len(matrix[0]))
    row_more = more == len(matrix)
    dp = [0 for i in range(less)]
    dp[0] = matrix[0][0]
    for i in range(1, less):
        dp[i] = dp[i - 1] + (matrix[0][i] if row_more else matrix[i][0])
    for i in range(1, more):
        dp[0] += matrix[i][0] if row_more else matrix[0][i]
        for j in range(1, less):
            value = matrix[i][j] if row_more else matrix[j][i]
            dp[j] = min(dp[j - 1], dp[j]) + value
    return dp[-1]
```