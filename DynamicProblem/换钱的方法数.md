### 换钱的方法数
> 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。  
> arr=[5，10，25，1]，aim=0。组成0元的方法有1种，就是所有面值的货币都不用。所以返回1。  
> arr=[5，10，25，1]，aim=15。组成15元的方法有6种，分别为3张5元、1张10元+1张5元、1张10元+5张1元、10张1元+1张5元、2张5元+5张1元和15张1元。所以返回6。  
> arr=[3，5]，aim=2。任何方法都无法组成2元。所以返回0。


**思路**

构建一个二维dp数组
dp[i][j] 表示用i种钱换取j钱数的方法数
第一列，都是1.因为换取0元只有一种方法

`
dp[i][0] = 1
`

第一行，如果j能整除array[i]就说明可以兑换，方法也是一种

`
dp[0][j] = dp[0][j-array[i]]
`

那么dp[i][j]可能有两种情况
- 不用当前货币的所有解 dp[i-1][j]
- 使用当前货币一张的所有解dp[i][j-array[i]]

两者的和就是当前的所有解法数了

`
dp[i][j] = dp[i-1][j]+dp[i][j-array[i]]
`

同样的，之和dp数组的上方值和左边值有关，可以压缩数组，只用1维数组实现
这个一维数组代表了二维dp数组的每一行

`
dp[j] += dp[j - array[i]] 
`

**代码**
```python
def coins(array: list, target: int):
    dp = [0 for i in range(target + 1)]
    dp[0] = 1
    for i in range(1, len(dp)):
        if i % array[0] == 0:
            dp[i] = 1
    for i in range(1, len(array)):
        for j in range(1, len(dp)):
            if j - array[i] >= 0:
                dp[j] += dp[j - array[i]]
    return dp[-1]
```