### 数字字符串转换为字母组合的种数
> 给定一个字符串str，str全部由数字字符组成，如果str中某一个或某相邻两个
> 字符组成的子串值在1～26之间，则这个子串可以转换为一个字母。规定"1"转
> 换为"A"，"2"转换为"B"，"3"转换为"C"..."26"转换为"Z"。写一个函数，求
> str有多少种不同的转换结果，并返回种数。

>str="1111"。能转换出的结果有"AAAA"、"LAA"、"ALA"、"AAL"和"LL"，返回5。
>
>str="01"。"0"没有对应的字母，而"01"根据规定不可转换，返回0。
>
>str="10"。能转换出的结果是"J"，返回1。

**思路**

一维dp问题
dp[i] 表示从0到i的子串能组成的解
遇到第i个数字
有两种情况
- 当前这个数字单独成为字符，此时前面有的情况，现在全有。dp[i] = dp[i-1]
- 当前这个数字和前一个数字组合成为新的字符，忽略它两，前面有多少现在有多少。dp[i] = dp[i-2]

整体解的数量等于两种情况加起来

`
dp[i] = dp[i-1]+dp[i-2]
`

按照题目的要求，有的时候不满足这个情况
比如111101

后面这个0的处理就需要不同的处理
0不能单独作为字符处理
所以不能加dp[i-1]

还有就是这样
181
最后这个1
和前面的81不能组合。所以不能加dp[i-2]

总和上面的情况
- 当前位置为0，不加dp[i-1]
- 前一个位置为0，或者和当前位置组合超过26，不加dp[i-2]

由于dp[i]只和dp[i-2]和dp[i-1]有关，所以不需要数组，只需要两个变量向前迭代即可
有一个地方需要特别说明
假设1111这个

| col | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- |
| 0   | 1   | 2   |

可以在最开始加0统一操作
但是第二个位置的值特殊
1和前一个位置结合，加上dp[i-2]，也就是0.这里应该再加一，因为往前没有字符了，组合的等于新生成的一个解


**代码**
```kotlin
fun getStringNums(str: String): Int {
    if (str.length == 1 && str[0] == '0') {
        return 0
    }
    if (str.length == 1 || str.isEmpty()) {
        return str.length
    }
    var pre = 0
    var post = if (str[0] == '0') 0 else 1
    val getValue = { preChar: Char, currentChar: Char ->
        var result = pre + post
        if (currentChar == '0') {
            result -= post
        }
        if (preChar == '0' || ((preChar - '0') * 10 + (currentChar - '0') > 26)) {
            result -= pre
        }
        result
    }
    var value = getValue(str[0], str[1])
    pre = post
    post = value + 1
    for (i in 2 until str.length) {
        value = getValue(str[i - 1], str[i])
        pre = post
        post = value
    }
    return post
}
```