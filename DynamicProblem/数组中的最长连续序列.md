# 数组中的最长连续序列
>给定无序数组arr，返回其中最长的连续序列的长度。
arr=[100，4，200，1，3，2]，最长的连续序列为[1，2，3，4]，所以返回4。

**思路**

利用hashmap保存每一个数字的最大连续长度。当遍历到一个数字，如果map中已有，不作处理。反之，看看hashmap中有没有它的前一个数值。
如果有的话，说明可以和前面的值合并

这个时候要注意

假设 [1,2,3]，现在遇到了4，和1,2,3合并，得到新的长度为4
那么，在hash中，1的value应该更新为4.如果在遇到0可以正确的结合。同样的，
4的value也应该为4

那么怎么找到这个1

遍历到4，查看hashmap存在3,此时3对应的value应该为3（1,2,3三个长度），那么用3减去value，再加上1就可以得到最左侧的值1
同时更新区间的最左边值和最右边值。中间的值是不用更新的。因为不会遇到和它们结合的数字了

当和左边的结合完，再看右边的

道理一样，从当前位置加上value再-1得到最右边的值

每次记录长度，比较出最大的即可

**代码**
```kotlin
fun longestConsecutive(num: IntArray): Int {
    if (num.isEmpty()) {
        return 0
    }
    val hashMap = HashMap<Int, Int>()
    var result = 1
    val merge = { low: Int, high: Int ->
        val left = low - hashMap[low]!! + 1
        val right = high + hashMap[high]!! - 1
        val len = right - left + 1
        hashMap[left] = len
        hashMap[right] = len
        result = max(result, len)
    }
    for (value in num) {
        if (!hashMap.containsKey(value)) {
            hashMap[value] = 1
            if (hashMap.containsKey(value - 1)) {
                merge(value - 1, value)
            }
            if (hashMap.containsKey(value + 1)) {
                merge(value, value + 1)
            }
        }
    }
    return result
}
```