# 数组中的最长连续序列
>给定无序数组arr，返回其中最长的连续序列的长度。
arr=[100，4，200，1，3，2]，最长的连续序列为[1，2，3，4]，所以返回4。

**思路**
--------------------

利用hashmap保存每一个数字的最大连续长度。当遍历到一个数字，如果map中已有，不作处理。反之，看看hashmap中有没有它的前一个数值。
如果有的话，说明可以和前面的值合并

这个时候要注意

假设 [1,2,3]，现在遇到了4，和1,2,3合并，得到新的长度为4
那么，在hash中，1的value应该更新为4.如果在遇到0可以正确的结合。同样的，
4的value也应该为4

那么怎么找到这个1

遍历到4，查看hashmap存在3,此时3对应的value应该为3（1,2,3三个长度），那么用3减去value，再加上1就可以得到最左侧的值1
同时更新区间的最左边值和最右边值。中间的值是不用更新的。因为不会遇到和它们结合的数字了

当和左边的结合完，再看右边的

道理一样，从当前位置加上value再-1得到最右边的值

每次记录长度，比较出最大的即可

**代码**
--------------------
```python
def longest_consecutive(nums: list):
    if len(nums) == 0:
        return 0
    len_map = {}
    result = 1

    def merge(low: int, high: int):
        left = low - len_map[low] + 1
        right = high + len_map[high] - 1
        length = right - left + 1
        len_map[left] = length
        len_map[right] = length
        return max(result, length)

    for value in nums:
        if not len_map.__contains__(value):
            len_map[value] = 1
            if len_map.__contains__(value - 1):
                result = merge(value - 1, value)
            if len_map.__contains__(value + 1):
                result = merge(value, value + 1)
    return result
```