# 矩阵的最短路径和
> 给出矩阵，每次只能往下或者往右。矩阵的值意味着走到这里的花费。计算出最小的花费

**思路**
二维dp问题
就是计算出左边走过来值更大还是上面走过来更大

`dp[0][0] = matrix[0][0] `


`dp[i][j] = min(dp[i][j-1],dp[i-1][j])`


进一步优化可以压缩这个二维的dp数组
可以选择按照行还是按照列遍历
因为dp值只和前面左边的和上面的有关
所以dp可以转换为1维的，不断比较之前的值就可以
dp[i-1]和dp[i]跟分别表示了左面的值和上面的值（也可能反过来，看是按照行遍历还是列遍历）

`dp[i] = min(dp[i-1],dp[i])+matrix[i][j]/matrix[j][i]`


**代码**

```kotlin
fun minPathSum(matrix: Array<IntArray>): Int {
    val more = max(matrix.size, matrix[0].size)
    val less = min(matrix.size, matrix[0].size)
    val rowMore = more == matrix.size
    val dp = IntArray(less)
    dp[0] = matrix[0][0]
    for (i in 1 until less) {
        dp[i] = dp[i - 1] + if (rowMore) matrix[0][i] else matrix[i][0]
    }
    for (i in 1 until more) {
        dp[0] += if (rowMore) matrix[i][0] else matrix[0][i]
        for (j in 1 until less) {
            val min = min(dp[j - 1], dp[j])
            val value = +if (rowMore) matrix[i][j] else matrix[j][i]
            dp[j] = min + value
        }
    }
    return dp.last()
}
```