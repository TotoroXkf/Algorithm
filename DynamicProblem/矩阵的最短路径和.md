# 矩阵的最短路径和
> 给出矩阵，每次只能往下或者往右。矩阵的值意味着走到这里的花费。计算出最小的花费

**思路**
二维dp问题 
就是计算出左边走过来值更大还是上面走过来更大  

`dp[0][0] = matrix[0][0] `


`dp[i][j] = min(dp[i][j-1],dp[i-1][j])`


进一步优化可以压缩这个二维的dp数组  
可以选择按照行还是按照列遍历  
因为dp值只和前面左边的和上面的有关  
所以dp可以转换为1维的，不断比较之前的值就可以  
dp[i-1]和dp[i]跟分别表示了左面的值和上面的值（也可能反过来，看是按照行遍历还是列遍历）  

`dp[i] = min(dp[i-1],dp[i])+matrix[i][j]/matrix[j][i]`


**代码**

```python
def min_path_sum(matrix: list):
    more = max(len(matrix), len(matrix[0]))
    less = min(len(matrix), len(matrix[0]))
    row_more = more == len(matrix)
    dp = [0 for i in range(less)]
    dp[0] = matrix[0][0]
    for i in range(1, less):
        dp[i] = dp[i - 1] + (matrix[0][i] if row_more else matrix[i][0])
    for i in range(1, more):
        dp[0] += matrix[i][0] if row_more else matrix[0][i]
        for j in range(1, less):
            value = matrix[i][j] if row_more else matrix[j][i]
            dp[j] = min(dp[j - 1], dp[j]) + value
    return dp[-1]
```