# 跳跃游戏

- [跳跃游戏](#跳跃游戏)
    - [跳跃游戏I](#跳跃游戏i)
    - [跳跃游戏II](#跳跃游戏ii)

## 跳跃游戏I
> 给定数组arr，arr[i]=k代表可以从位置i向右跳1～k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。  
输入：[2,3,1,1,4]
输出 2  
先跳到3，再跳到4  

**思路**
--------------------

还是先抽象问题
数组

`
[a,b,c,d,e,f,g]
`

刚开始从a开始，这是一定的

a能调跳到的范围是a+0

也就是下标加对应的值

假设最远到d

那么中间跳到哪里该怎么确定呢？

其实就是选那个可以跳的远的。
- 假设选b那么在往后的范围是b+1
- 假设选c那么在往后的范围是c+2
- 假设选d那么在往后的范围是d+3

应该选出

`
max(b+1,c+2,d+3)
`

下一步能跳的越远越好。因为跳的远会包含跳的近的情况，这是毋庸置疑的

同时，一旦走出d，就要步数+1
假设下一步选了c，那么再走出c+2就要步数加1了

由此分析，每走一步比较出最大的下标加对应值作为下一步可达的最远距离。这个是选择下一步位置的参考
同时，记录下来当前选定的距离的极限值，超过这个距离结果就加1


**代码**
--------------------

```python
def jump(nums: list):
    result, cur, next_position = 0, 0, 0
    for i in range(len(nums)):
        if i > cur:
            result += 1
            cur = next_position
        next_position = max(next_position, nums[i]+i)
    return result
```

## 跳跃游戏II
> 规则和上面的一样，但是现在是判断能不能跳跃到最后一个位置

> 输入: [3,2,1,0,4]  
输出: false  
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。  

**思路**
--------------------

有了上面一题的基础就很容易了。当越过当前位置要到下一个位置时，如果写一个位置还是当前位置就说明无法前进，返回False。不然循环完就是True

**代码**
--------------------

```python
def canJump(nums: list):
    cur, next_position = 0, 0
    for i in range(len(nums)):
        if i > cur:
            if next_position == cur:
                return False
            cur = next_position
        next_position = max(next_position, nums[i] + i)
    return True
```

