# 换钱的最少货币数
> arr=[ 5， 2， 3]， aim= 20。 4张5元可以组成20元， 其他的找钱方案都要使用更多张 的货币所以返回4。 
> arr=[ 5， 2， 3]， aim= 0。不用任何货币就可以组成0元，返回0。
> arr=[3，5]，aim= 2。 根本无法组成2元，钱不能找开的情况下默认返回- 1。

**思路**
这是一个二维的dp问题
dp[i][j]表示用前i种钱找这么多钱需要的最少货币数
初始化都是MAX，这样方便使用min比较
第一行好处理，能整除第一种钱的都是 整除的值
第一列是0所对应的列，都是0

`dp[0][0] = 0`

`
dp[0][j] = if(j%i==0)  j/i  else MAX
`

`
dp[i][0] = 0
`

那么怎么考虑dp[i][j]呢？
有两种情况
- 不考虑当前这种钱币，只用之前的一种钱币就可以了。dp[i][j]=dp[i-1][j]
- 使用当前这张钱，等同于使用之前的最优解+1。dp[i][j]=dp[i][j-array[i]]+1

所以

`
dp[i][j] = min(dp[i-1][j],dp[i][j-array[i]]+1)
`

另外可以优化的就是空间上的压缩
每一次的解也就之和上方的解和左侧的解有关
所以一维的dp数组就可以胜任
把二维的dp数组改成按行遍历的一行一行的dp数组
滚动即可

`
dp[j] = min(dp[j],dp[j-array[i]+1)
`

**代码**

```kotlin
fun minCoins(array: IntArray, target: Int): Int {
    val dp = IntArray(target + 1) { _ -> Int.MAX_VALUE }
    dp[0] = 0
    for (i in 1..target) {
        if (i >= array[0] && dp[i - array[0]] != Int.MAX_VALUE) {
            dp[i] = dp[i - array[0]] + 1
        }
    }
    for (i in 1 until array.size) {
        for (j in 1..target) {
            var value = Int.MAX_VALUE
            if (j >= array[i] && dp[j - array[i]] != Int.MAX_VALUE) {
                value = dp[j - array[i]] + 1
            }
            dp[j] = min(dp[j], value)
        }
    }
    return if (dp.last() == Int.MAX_VALUE) -1 else dp.last()
}
```