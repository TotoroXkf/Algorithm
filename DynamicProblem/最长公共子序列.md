# 最长公共子序列
> 给定两个字符串str1和str2，返回两个字符串的最长公共子序列。
> 例如：
str1="1A2C3D4B56"，str2="B1D23CA45B6A"。"123456"或者"12C4B6"都是最长公共子序列，返回哪一个都行。

**思路**

经典的动态规划问题
按照两个字符串列出二维的dp数组。额外增加一列一行使得操作统一

dp[i][j]表示str1[i]和str2[j]的匹配长度
`
dp[0][j] = 0
`
`
dp[i][0] = 0
`
假设遇到i，j位置了
那么匹配当前的情况就是
- str1不看当前字符，看看匹配的长度。也就是dp[i-1][j]
- str2不看当前的字符，看看匹配的长度。也就是dp[i][j-1]
- 两个都看当前的字符，如果str1[i] == str2[j] ，说明当前字符相等，长度可能是前面一个字符匹配长度+1。dp[i-1][j-1]+1

`
dp[i][j] = max(dp[i-1][j],dp[i][j-1])
` 

`
if (str1[i] == str2[j])
`

`
dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)
`

得到了dp数组之后，要想得到字符串，需要倒着重复这个dp求解的过程
从dp数组的最后一个元素开始
等于dp[i-1][j] 就向上走
等于dp[i][j-1]就向左走
不然就向左上方走。向左上方走说明当前这个字符是两个字符串的公共字符，记录下来

最后返回结果即可

**代码**

```python
def get_max_len_common(str1: str, str2: str):
    if len(str1) == 0 or len(str2) == 0:
        return ""

    def get_dp():
        dp = [[0 for i in range(len(str2)+1)] for j in range(len(str1)+1)]
        for i in range(1, len(dp)):
            for j in range(1, len(dp[0])):
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)
        return dp

    dp = get_dp()
    i, j = len(dp)-1, len(dp[0])-1
    res = ['' for i in range(dp[-1][-1])]
    index = len(res)-1
    while dp[i][j] != 0:
        if dp[i][j] == dp[i-1][j]:
            i -= 1
        elif dp[i][j] == dp[i][j - 1]:
            j -= 1
        else:
            res[index] = str1[i-1]
            index, i, j = index-1, i-1, j-1
    return "".join(res)
```