# 最长公共子串
> 类似上面的问题。不过这次是子串
> str1="1AB2345CD"，str2="12345EF"，返回"2345"。

**思路**
--------------------

还是二维dp的问题  
dp[i][j]表示str1[i]和str2[j]的以str1第i个字符结束的子串和str2的第j个字符结束的子串匹配长度

`
str1[i]!=str[j]
`

`
dp[i][j] = 0
`

`
str1[i]==str[j]
`

`
dp[i][j] = dp[i-1][j-1]+1
`

同时记录最大值即可  
这个题还可以优化空间复杂度到1  
因为当前的dp值之和左上方的值有关  
所以可以斜着遍历  
这样就可以只用常熟空间复杂度完成  
![Alt text](./images/1536571892291.png)  
同时记录end的位置  
截取对应的子串即可  

**代码**
--------------------
```python
def get_max_len_sub_string(str1: str, str2: str):
    if len(str1) == 0 or len(str2) == 0:
        return ""
    end, max_len, i, j = 0, 0, 0, len(str2) - 1

    def loop():
        nonlocal i, j, end, max_len
        length = 0
        while i < len(str1) and j < len(str2):
            if str1[i] == str2[j]:
                length += 1
            else:
                length = 0
            if length > max_len:
                max_len = length
                end = i
            i += 1
            j += 1

    while j > 0:
        i = 0
        position = j
        loop()
        j = position - 1
    i = 1
    while i < len(str1):
        j = 0
        position = i
        loop()
        i = position + 1
    return str1[end - max_len + 1:end + 1]
```