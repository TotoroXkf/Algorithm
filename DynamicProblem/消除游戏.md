# 消除游戏
> 给定一个从1 到 n 排序的整数列表。  
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。  
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。  
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。  
返回长度为 n 的列表中，最后剩下的数字。  
输入:
n = 9  
1 2 3 4 5 6 7 8 9  
2 4 6 8  
2 6  
6  
输出:6

**思路**

首先看简单的情况

1 -> 1

1,2 -> 2

1,2,3 -> 2

1,2,3,4 -> 2

分情况讨论

当最后一个数字是偶数的时候

当从左向右消除的时候，剩下的都是偶数。并且反过来看的话等同于将长度缩短一半解

比如4长度，从左往右删除过后剩下2,4，相当于从后往前看2长度的解

当最后一个数字是奇数的时候

从左往右第一次消除一定消除最后一个数字。所以完全可以假设没有最后这个奇数，反正第一次一定就删除了

所以它的解等于当前长度减去1的解

比如3长度，第一次直接删除了3，可以当作没有这个3，等于从左向右2长度的解

所以可以推出写法

给出n
- n是偶数，计算n/2的解，表示n/2的情况下应该保留第几个数字。因为要倒着看，所以用n减去（（x-1）* 2）的值得到倒着看的解
- n是奇数，直接计算n-1的解

**代码**

```kotlin
fun lastRemaining(n: Int): Int {
    if (n == 1) {
        return 1
    }
    if (n % 2 == 0) {
        val value = lastRemaining(n / 2) - 1
        return n - value * 2
    } else {
        return lastRemaining(n - 1)
    }
}
```