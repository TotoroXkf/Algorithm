# 数独问题

- [数独问题](#数独问题)
    - [判断数独是否正确](#判断数独是否正确)
    - [解数独](#解数独)

## 判断数独是否正确

>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可 
>1. 数字 1-9 在每一行只能出现一次。
>2. 数字 1-9 在每一列只能出现一次。
>3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

**思路**
--------------------

就是按照规则去判断是否成立。可以牺牲空间换取时间。通过维护3个set，分别保存9宫格，行，列已经出现过的值。这样就可以只遍历一次二维数组就得到答案

假设遍历到(i,j)位置
- 判断row_set[i]是否包含。不包含加入row_set[i]
- 判断col_set[j]是否包含。不包含加入col_set[j]
- 9个板块从左到右，从上到下是0-9。i / 3 * 3 + j / 3科一得到相应的位置。判断area_set[i / 3 * 3 + j / 3]是否包含。不包含加入area_set[i / 3 * 3 + j / 3]


**代码**
--------------------

```python
def is_valid_sudoku(board: list):
    row_set = [set() for _ in range(9)]
    col_set = [set() for _ in range(9)]
    area_set = [set() for _ in range(9)]
    for i in range(9):
        for j in range(9):
            if board[i][j] != '.':
                value = board[i][j]
                area_position = i // 3 * 3 + j // 3
                if value in row_set[i] or value in col_set[j] or value in area_set[area_position]:
                    return False
                else:
                    row_set[i].add(value)
                    col_set[j].add(value)
                    area_set[area_position].add(value)
    return True
```

## 解数独
> 给定一个初始数独，填充它。


**思路**
--------------------

dfs的应用

按照上面题的做法，维护三个set，然后一次遍历把原始数字放入到对应的set里面。

然后再次遍历，循环放入数字。已经在set里面的不放入，不在set里面的就放入，然后向后继续放入。如果发现所有数字都放不进去，就返回fasle，回朔。这样就可以尝试到所有的情况，填充数独

**代码**
--------------------
```python
def solve_sudoku(board: list):
    row_set = [set() for _ in range(9)]
    col_set = [set() for _ in range(9)]
    area_set = [set() for _ in range(9)]
    for i in range(9):
        for j in range(9):
            if board[i][j] != ".":
                row_set[i].add(board[i][j])
                col_set[j].add(board[i][j])
                area_set[i // 3 * 3 + j // 3].add(board[i][j])
    solve(board, row_set, col_set, area_set, 0, 0)


def solve(board: list, row_set: list, col_set: list, area_set: list, i, j):
    if j >= 9:
        i += 1
        j = 0
    if i >= 9:
        return True
    area_position = i // 3 * 3 + j // 3
    if board[i][j] != '.':
        return solve(board, row_set, col_set, area_set, i, j + 1)
    for number in range(1, 10):
        value = str(number)
        if value not in row_set[i] and value not in col_set[j] and value not in area_set[area_position]:
            board[i][j] = value
            row_set[i].add(board[i][j])
            col_set[j].add(board[i][j])
            area_set[area_position].add(board[i][j])
            result = solve(board, row_set, col_set, area_set, i, j + 1)
            if not result:
                row_set[i].remove(board[i][j])
                col_set[j].remove(board[i][j])
                area_set[area_position].remove(board[i][j])
            else:
                return True
    board[i][j] = "."
    return False
```