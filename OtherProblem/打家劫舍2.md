### 打家劫舍2
>和1的情况差不多，但是首尾是相通的。选了最后一个就不能选第一个了

**思路**

举个例子  
[a,b,c,d,e]  
如果包含a有哪些可能的解呢？  
只可能是  
- [a,c]
- [a,d]  
  
包含a的解一定包含在从0到length-2的dp解（见1）

再看不包含a的解
- [b,d]
- [b,e]
- [c,e]
  
同理，是从1到length-1的dp的解

两次dp求解即可

**代码**

```kotlin
fun rob(nums: IntArray): Int {
    if (nums.isEmpty()) {
        return 0
    }
    if (nums.size == 1) {
        return nums[0]
    }
    if (nums.size == 2) {
        return Math.max(nums[0], nums[1])
    }
    val dp = IntArray(nums.size)
    return Math.max(rob(nums, 0, dp.size - 1, dp), rob(nums, 1, dp.size, dp))
}

private fun rob(nums: IntArray, start: Int, end: Int, dp: IntArray): Int {
    dp[start] = nums[start]
    dp[start + 1] = Math.max(nums[start], nums[start + 1])
    for (i in start + 2 until end) {
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
    }
    return dp[end - 1]
}

```

