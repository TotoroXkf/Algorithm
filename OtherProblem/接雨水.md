# 接雨水
> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://leetcode-cn.com/static/images/problemset/rainwatertrap.png)

>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

> 示例:  
输入: [0,1,0,2,1,0,1,3,2,1,2,1]  
输出: 6  

**思路**
--------------------

比较需要分析能力的一个题目。其实说白了，对于中间的任何一个位置，它能不能接上雨水，能接多少是这样判断的
- 如果它的左边有比它大的数，且右边也有比它大的数，就能接水。否则不能接水
- 如果能接水，它左边的最大值，和它右边的最大值，取小的一个，减去它就是它能接的水量

比如 2 1 0 1 3这段

看中间的0.它其实是处在2这个左边的高峰和3这个右边的高峰之间的。他就应该被填充成为2.包括2和3中间的所有数都应该。

所以说，先找到这个数组的最大值。然后从最左边向最大值跑。同时维护遇到的最大值。遇到一个数，看看是不是比最大值大，如果小于之前遇到的最大值，说明这个数左边的最大值就是维护的最大值，而右边的最大值一定是之前求出的最大值。这里也不用取小了，自己维护的最大值一定是小的。让结果加上维护最大值和高度的差值即可。

如果这个数大于维护最大值，就说明它的左边没有比它大的，那就不能接水了。更新最大值，往后继续

完了之后从右向最大值位置跑，过程处理一模一样。

**代码**
--------------------

```python
def trap(height: list):
    if len(height) == 0:
        return 0
    max_value_index = height.index(max(height))
    result, border = 0, height[0]
    for i in range(1, max_value_index):
        if height[i] > border:
            border = height[i]
        else:
            result += (border - height[i])
    border = height[-1]
    for i in range(len(height) - 2, max_value_index, -1):
        if height[i] > border:
            border = height[i]
        else:
            result += (border - height[i])
    return result
```
