# 灯泡开关

>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。
>示例:  
输入: 3  
输出: 1   
解释:   
初始时, 灯泡状态 [关闭, 关闭, 关闭].  
第一轮后, 灯泡状态 [开启, 开启, 开启].  
第二轮后, 灯泡状态 [开启, 关闭, 开启].  
第三轮后, 灯泡状态 [开启, 关闭, 关闭].   
你应该返回 1，因为只有一个灯泡还亮着。  

**思路**
--------------------

很经典的逻辑问题了。我们一步一步来分析这个问题

我们可以按照动态规划的思想来看待这个问题。dp[i]表示第i轮有多少个灯泡亮着。

到了第i轮，那么前i-1个灯泡的状态是不变的。第i个灯泡若果亮着，dp[i]就+1。所以`dp[i]  =  dp[i-1]+（1或0）`。如果i有偶数个因数，就说明要改变偶数次，最后就是灭的。因数个数是奇数次就是亮的

我们不妨列举一些若干情况

`dp[0] = 0`    
`dp[1] = 1`   
`dp[2] = 1`  
`dp[3] = 1`  
`dp[4] = 2`  
`dp[..] = 2`  
`dp[9] = 3`  
`dp[..] = 3`  
`dp[16] = 4`  
`dp[..] = 4`  
`dp[25] = 5`

.....

这样就看到规律了，在1,2,3...这样的自然数的平方的时候会+1。而且最终的救过就是开更号的结果。

所以说，给出n，直接开更号然后向下取整即可。

**代码**
--------------------

```python
def bulb_switch(n: int):
    return int(sqrt(n))
```