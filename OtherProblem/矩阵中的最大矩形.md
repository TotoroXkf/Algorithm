# 矩阵中的最大矩形
> 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

输入:  
[  
&emsp;&emsp;["1","0","1","0","0"],  
&emsp;&emsp;["1","0","1","1","1"],  
&emsp;&emsp;["1","1","1","1","1"],  
&emsp;&emsp;["1","0","0","1","0"]  
]

输出: 6

**思路**

需要用到这个题的函数和思路

[柱状图中最大的矩形](https://github.com/TotoroXkf/Algorithm/blob/master/src/OtherProblem/柱状图中最大的矩形.md)

这个问题其实就是它的二维形式

分析这个矩阵。假设就一行1 0 1 0 0。那好办。构建一个1,0,1,0,0这个数组，传下去求解就可以了

然后看二维的  

1 0 1 0 0  
1 0 1 1 1

这会就是看最底下的一行，向上延伸，有1就加1
构建数组2,0,2,1,1。求解即可

1 0 1 0 0  
1 0 1 1 1  
1 1 1 1 1  

还是看最下面一行。构建数组3,1,3,2,2

1 0 1 0 0  
1 0 1 1 1  
1 1 1 1 1  
1 0 0 1 0  

构建数组 4,0,0,1,0

可以总结规律了。遍历二维数组，同时维护一个一位数组。遍历二维数组的每一行的时候，遇到1就在一维数组的位置上加1。遇到0就置0。因为遍历到的行都是当前最底下的一行，遇到0就是0了。

**代码**

```python
def maximal_rectangle(matrix: list):
    rows = len(matrix)
    if rows == 0:
        return 0
    cols = len(matrix[0])
    if cols == 0:
        return 0
    height = [0 for _ in range(cols)]
    result = 0
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == '1':
                height[j] += 1
            else:
                height[j] = 0
        result = max(result, largest_rectangle_area(height))
    return result


def largest_rectangle_area(heights: list):
    result = 0
    stack = []
    size = len(heights)
    for i in range(0, size + 1):
        height = 0
        if i < size:
            height = heights[i]
        while len(stack) > 0 and heights[stack[-1]] > height:
            position = stack.pop(-1)
            if len(stack) == 0:
                area = heights[position] * i
            else:
                area = (i - stack[-1] - 1) * heights[position]
            if area > result:
                result = area
        stack.append(i)
    return result
```


     