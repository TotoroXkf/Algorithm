# 柱状图和矩阵中的中最大的矩形

- [柱状图和矩阵中的中最大的矩形](#柱状图和矩阵中的中最大的矩形)
    - [柱状图中](#柱状图中)
    - [矩形中](#矩形中)

## 柱状图中
> 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

![image](https://leetcode-cn.com/static/images/problemset/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

![image](https://leetcode-cn.com/static/images/problemset/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

**思路**

一点一点分析这个问题

首先考虑比较简单的情况。如果全部都是升序的是个什么情况？比如1,3,4,7,11。

那么，可能情况就是1*5||3*4||4*3||7*2||11*1，其中有一个最大值

然后考虑在升序当中出现乱序的情况，比如2,3,1。这时的最大值可以这样想。抛开1不管，只看2和3是有序的，是可以必出2和3组成的最大值。然后1加入，1比2和3都小。那么就会多出一种情况就是带着1跨过整个数组，13的情况

比较上面的的值可以求出最大值

再然后考虑更复杂的情况，1后面假设还有值2,3,1,2,3。先看1左边的2和3，得出各种情况。然后遇到1，但是这时不应该处理1，因为1后面还有数字，不知道是带着1向后还是1就在这里处理。所以不处理。但是这时的2和3已经处理过了。所以完全可以大胆的把2和3都看作1！因为2和3想要向后扩展必须跨过1，那就只能视作为1.而不跨过1的情况已经处理过了。所以大胆看作1。变成1,1,1,2,3 这时再次得到升序的数组，求解即可

再来看更加特殊的情况 1,3,4,2,6,5。这基本可以当做一般情况了
首先1,3,4有序，遇到2，这时，2大于1，也就是说没有办法让2没过1，所以即使1,3,4,有序，但是也只能处理3和4。然后变成1,2,2,2,6,5。6和5还不是有序的。但是流程和之前的是一样的。1,2,2,2,6是有序的，遇到5......

综上所述。这个题的关键就是要不断地创建一个升序的数组。在构建的途中处理不是升序的部分，求得最优解

这里提供一个完整的分析，配合下面的代码分析清楚这个题

比如4,2,0,3,2,5这个例子

1. 首先遇到4，没问题，把4的下标(必须是下标)进栈。然后遇到2，和栈顶比较，比4小，入栈会成为无序，所以把4出栈

2. 然后这时的i在1位置，出栈的元素代表的位置是0。此时栈为空，长就是4，宽就是4 * i。想想看，栈空了，表示遇到的元素小于栈里面所有的元素。比如2,6,9,1这种。遇到1，6和9都出栈了，2的处理就因该是2*3
所以此时，就是4去乘上i所在的位置表示area

3. 然后理论上这个数组因该就变成2,2,0,3,2,5了。但是在写法上不用这样。直接把2所在的下标，也就是1入栈就好了。这也是间接的表示1下标之前的数字都是2

4. 随后遇到0把2的下标1出栈,然后栈空，area是2*i(i此时是2);
再遇到3，入栈，遇到2，把3弹出，这时栈不为空，还有个0的下标在里面。此时area应该是i-2(栈顶元素，也就是0的下标)-1。**这里注意，一定是减去栈顶的下标。为什么之后说**

5. 然后2入栈，遇到5，入栈。遍历结束。这时要在处理一次栈。也就是在数组末尾假装还有一个0.这样按照上面的分析就能把栈里面的元素都给处理了
现在遇到自己加入的0，此时的栈为2(0的下标),4(后面那个2的下标),5(5的下标)。

    5出栈，5*(6-4-1) = 5*1 = 5

    4出栈，2*(6-2-1) = 2*3 = 6   (这个例子中的最大值)

    2出栈，0*6 = 0;

结束

现在说说为什么是减去栈顶元素

按照上面的分析，最后一次数组应该已经成为0,0,0,2,2,5。在弹出5的时候，5只有自己一个值，那么就算是不这么算也是可以的。比如用i减去弹出的栈顶元素也可以算出宽度来。但是弹出4的时候就不是了。3位置也是个2，也因该一并考虑进去的，此时如果还是用i减去弹出的栈顶元素，那么就算了2*2，漏掉了3位置的2，
     

**代码**
```python
def largest_rectangle_area(heights: list):
    result = 0
    stack = []
    size = len(heights)
    for i in range(0, size + 1):
        height = 0
        if i < size:
            height = heights[i]
        while len(stack) > 0 and heights[stack[-1]] > height:
            position = stack.pop(-1)
            if len(stack) == 0:
                area = heights[position] * i
            else:
                area = (i - stack[-1] - 1) * heights[position]
            if area > result:
                result = area
        stack.append(i)
    return result
```

## 矩形中

> 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

输入:  
[  
&emsp;&emsp;["1","0","1","0","0"],  
&emsp;&emsp;["1","0","1","1","1"],  
&emsp;&emsp;["1","1","1","1","1"],  
&emsp;&emsp;["1","0","0","1","0"]  
]

输出: 6

**思路**


这个问题其实就是上面的二维形式

分析这个矩阵。假设就一行1 0 1 0 0。那好办。构建一个1,0,1,0,0这个数组，传下去求解就可以了

然后看二维的  

1 0 1 0 0  
1 0 1 1 1

这会就是看最底下的一行，向上延伸，有1就加1
构建数组2,0,2,1,1。求解即可

1 0 1 0 0  
1 0 1 1 1  
1 1 1 1 1  

还是看最下面一行。构建数组3,1,3,2,2

1 0 1 0 0  
1 0 1 1 1  
1 1 1 1 1  
1 0 0 1 0  

构建数组 4,0,0,1,0

可以总结规律了。遍历二维数组，同时维护一个一位数组。遍历二维数组的每一行的时候，遇到1就在一维数组的位置上加1。遇到0就置0。因为遍历到的行都是当前最底下的一行，遇到0就是0了。

**代码**

```python
def maximal_rectangle(matrix: list):
    rows = len(matrix)
    if rows == 0:
        return 0
    cols = len(matrix[0])
    if cols == 0:
        return 0
    height = [0 for _ in range(cols)]
    result = 0
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == '1':
                height[j] += 1
            else:
                height[j] = 0
        result = max(result, largest_rectangle_area(height))
    return result


def largest_rectangle_area(heights: list):
    result = 0
    stack = []
    size = len(heights)
    for i in range(0, size + 1):
        height = 0
        if i < size:
            height = heights[i]
        while len(stack) > 0 and heights[stack[-1]] > height:
            position = stack.pop(-1)
            if len(stack) == 0:
                area = heights[position] * i
            else:
                area = (i - stack[-1] - 1) * heights[position]
            if area > result:
                result = area
        stack.append(i)
    return result
```